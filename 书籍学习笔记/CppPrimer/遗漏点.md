



**记录一些遗漏的C++知识点**

[TOC]

---

#### 基础遗漏

1. `e`指数表示：`1.3e3`表示1300

2. 末尾可以用`\`换行

3. 字面值常量的前缀和后缀添加，改变默认类型，在不同类型上应用会有不同效果。  
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符、字符串(前缀):

    * `u`char16_t
    * `U`char32_t
    * `L`wchar_t
    * `u8`char(UTF-8)  
      整形:
    * `u/U`unsigned
    * `l/L`long
    * `ul/UL`unsigned long
    * `ll/LL`long long  
      浮点数:
    * `f/F`float
    * `l/L`long double

4. 变量声明和定义的区别。一个变量能且仅能够被定义一次，但是可以被多次声明(extern)，声明时不需要初始化，若是声明时初始化则不是声明而是定义，如`extern int i = 3`已经变化为定义。

5. `::变量名`显式的访问全局变量中的变量，若是有局部变量名与全局变量名相同时，可以如此访问。`::i/i`（全局作用域没有名字）

6. 引用的类型必须与所引用的对象的类型一致。除了：

   * `const int &r = 10;`正确，直接用常量值绑定
   * `int i = 1;int &r1 = i;const int &r2 = i;`此时可以通过r1或直接修改i的值，但是不能通过r2修改值。

7. 指针和const

   * `const int *p = &i;`此时p指向的地址可以修改，但是不能改变其所指地址对象的值，并不要求所指对象是常量值，仅仅是表示不能通过该指针修改其值。
   * `int *const p = &i;`表示指针本身是常量，其所指的地址不能改变。
   * `const int *const p =&i;`**一般把前const称作底层const,后const称作顶层const，拷贝赋值时必须有相同的底层const。当然普通类型可以转化为const类型，反之不行。**

8. 常量表达式关键字`constexpr`，常量表达式由**数据类型**和**初始值**共同决定。  

   * `constexpr int t = 20;`常量表达式
   * `constexpr int sz = size()`**只有size()函数是一个constexpr函数时才是正确的声明语句，新标准允许定义一种特殊的constexpr函数(返回值必须是字面值常量，传递进去的实参必须是字面值常量，函数体中必须有且仅有一条return语句)<font color='red'> |算术类型、引用、某个固定地址的指针都属于字面值常量| </font>使得编译时就获得结果**

   > 注意，`constexpr`修饰指针时与const不同，`constexpr int *p = nullptr`表示p该指针指向不能改变。

9. 基于范围的for语句  

```c++
// string a - 处理每个字符
for(auto c:a) {
    cout << c;
}
// 若要改变字符，需要使用引用
for(auto &c:a) {
    c = c + '1';
}
// 若要处理多维数，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型
for(auto &row:a) {
    for(auto &x:row){
        ...
    }
}
```

10. 数组的指针

    * `int *ptr[10];`含有10个整型指针的数组
    * `int (*ptr)[10]`指针指向一个含有10个整数的数组
    * `int &ptr[10];`不存在引用的数组
    * `int (&ptr)[10];`引用一个含有10个整数的数组  

    > 头文件`<iterator>`定义了函数`begin()/end()`方便我们获得数组的头指针和尾元素下一个位置的指针。

11. char数组的比较：不能直接使用运算符比较，此时比较的是指针而非值本身。要使用`strcmp`

12. 可变形参

    * `initializer_list<T>`所有实参类型需要相同，其中对象永远为常量值，不可以修改其对象中的值。

13. 内联函数和constexpr函数

14. `assert(表达式)`如果表达式为0输出信息并终止程序执行，表达式为1，什么都不做。依赖于`NDEBUG`预处理变量，如果定义了`#define NDEBUG`则`assert`什么都不做。

15. 预处理器的四个内置变量

    * `__FILE__`:存放文件名的字符串字面值
    * `__LINE__`:存放当前行号的整形字面值
    * `__TIME__`:存放文件编译时间的字符串字面值
    * `__DATE__`:存放文件编译日期的字符串字面值
    * `__func__`:存放当前函数名的字符串字面值

16. `namespace name{代码块}`

17. 

---

#### 类型处理

##### 别名

&nbsp;&nbsp;推荐使用`using`代替`typedef`，`using`比起`typedef`来易读，并且支持模板别名。</br>

* `using func = void(*)(int);`
* `template<typename T> using map_ss = unordered_map<std::string, T>;`<br/>
  `map_ss<int> unmap;// ==> unordered_map<std::string, int> unmap;`

##### 类型推导

* `auto`关键字，推导时会去掉顶层const，需要手动加`const auto i = 1;`
* `decltype(变量/值...)`，获取某个值的类型，`decltype(sum()) x = sum()`;`decltype`中的值如果加了括号，如`decltype((i))`(->一定为引用的类型)和`decltype(i)`不同。

```C++
//推导函数
int a(int b){};
decltype(a)* p = a// 指向函数a的指针。
```

* 

---

#### 特性

* `[[noreturn]]` 指定函数永不返回
* `[[carries_dependency]]`指定函数传播线程同步的数据依赖项顺序。 可将该属性应用于一个或多个参数，以指定传入的参数要将依赖项带入函数主体中。 可将该属性应用于函数本身，以指定返回值要将依赖项带出函数。 编译器可以使用此信息来生成更有效的代码。
* `[[deprecated]]`特性 [[deprecated]] 可以应用于类、typedef-name、变量、非静态数据成员、函数、命名空间、枚举、枚举器或模板专用化的声明。 当客户端代码尝试调用该函数时，编译器可以使用此属性来生成信息性消息。 当Microsoft C++ 编译器检测到项的使用[[deprecated]]时，会引发编译器警告 C4996。
* `[[fallthrough]]`指定函数的返回值不应被丢弃。
* `[[nodiscard]]`
* `[[maybe_unused]]`
* `[[likely]]`
* ``[[unlikely]]``

---

#### 命名空间

* `using namespace 命名空间名`使用该命名空间所有名字
* `using 命名空间名::具体名字`，如:`using std::cin`

---

#### 运算符

* `typeid`定义在<typeinfo>头文件中，允许在运行时获得变量的类型名。例子：`int a;cout << typeid(a).name();`可以在模板中使用，确定类型。`typeid(T).name()`
* `alignof(类型名)`返回类型的字节数。`class Car{};cout << alignof(Car);`
* `alignas(类型名)`修改单独变量或者类的对齐大小，在定义时添加使用
* `sizeof...(name)`参数包的大小
* `throw expr`抛出异常
* `noexcept(expr)`不带参数等价于true，当 noexcept 是 true 时表示函数不会抛出异常，
  当 noexcept 是 false 时表示函数可能会抛出异常，可以定义在函数中，也可以单独使用`noexcept(函数名(实参))`检查函数声明的是true还是false。`void g() noexcept {};`带参用来检测某个行为是否会引发异常`template <class T> void swap(T &a, T &b) noexcept(noexcept (T(std::move(a))) && noexcept (a.operator=(std::move(b)))) `

```C++
struct stTestAlign
{
    char a;
    alignas(4) char b;
    stTestAlign()
    {
        cout << "sizeof(stTestAlign) =" << sizeof(stTestAlign) << endl;   //8
        cout << "alignof(stTestAlign) =" << alignof(stTestAlign) << endl; //4
    }
};
// 同时修改类的对齐依据，跟变量的(4)两者对齐依据取其大
struct alignas(2) stTestAlign
{
    char a;
    alignas(4) char b;
    stTestAlign()
    {
        cout << "sizeof(stTestAlign) =" << sizeof(stTestAlign) << endl;   //8
        cout << "alignof(stTestAlign) =" << alignof(stTestAlign) << endl; //4
    }
};

```

---

#### 类

* 常量成员函数` int GetYear() const { return y; }`。在函数中只能访问本类的其他常量成员函数，同时不能修改成员变量（除了标记为mutable的成员变量）
* 友元函数，在类外定义的函数在类内使用`friend`关键字再次声明后，该函数可以修改类的私有成员。也可以指定友元类，友元类的对象可以操作该类的私有成员。也可以仅令其他类的某个成员函数为友元函数:`friend type 类名::name(...);`
* 如果成员是const、引用，或者属于类类型，必须通过构造函数初始值列表为成员提供初值，不能放在打括号内初始化。`:i(放在这里){不能放在这里;}`
* 回避虚函数的机制，**强行调用某个版本的函数，`pojo.Class::func()`，这里强行调用了类Class中的函数版本**
* <font color="red">委托构造函数</font>，把构造函数初始化值的过程交给其它构造函数来完成。

```C++
class Person
{
public:
    Person() :Person(1, 'a') {}
    Person(int i) : Person(i, 'a') {}
    Person(char ch) : Person(1, ch) {} 
 
private:
    Person(int i, char ch) :type(i), name(ch) {/*其他初始化信息*/}
    int type{ 1 };
    char name{ 'a' };
};
```

* 字面值常量类：字面值类型的要求
  - 数据成员都必须是字面值类型
  - 类必须至少含有一个`constexpr`构造函数,`constexpr`构造函数必须初始化所有数据成员
  - 如果数据成员含有类内初始值，则该初始值必须是一条常量表达式，若成员为类类型，则初始值必须使用该类型的`constexpr`构造函数
  - 类必须使用析构函数的默认定义
* 类的静态成员函数使用：`类名::静态成员函数(...)`。类的静态成员定义在类外（除了静态**常量成员**可以定义在类内）：`type 类::成员变量名 = 初始化值`，即使静态成员在类内定义初始化后，也要在类的外部定义一下该成员。

> 静态成员和普通成员的区别，静态类成员类型可以就是他所属的类的类型，而普通成员必须是该类类型的指针或引用。

---

##### 拷贝、赋值、销毁

当定义一个类时，**通过定义5种特殊的成员函数控制这些操作，拷贝初始化（<font color="red">用等号定义变量</font>）通过拷贝构造函数或者移动构造函数实现的，`=delete`表示删除不使用该函数：**

* 拷贝构造函数：一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数为拷贝构造函数。**是用一个对象初始化另一个没有创建的对象**

  ~~~c++
  class Foo{
  public:
      Foo(const Foo&);
  }
  string Foo(...) // 直接初始化
  string s = Foo // 拷贝初始化
  ~~~

  

* 拷贝赋值运算符：**两个已经都存在的对象间进行赋值，一般会析构左侧对象，拷贝右侧对象。**

  ```c++
  Foo& operator=(const Foo&);
  ```

  >  <font color="red">拷贝和赋值运算符，都要注意传递将要赋值的对象!=(*this)</font>

* 移动构造函数

* 移动赋值运算符：

* 析构函数

> 拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么，拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。



---

##### Swap

一般类希望定义一个自己版本的swap，可以定义一个专属的swap友元函数。**将该函数声明为Inline用来优化加速，通常我们的交换只需要交换两个对象的指针。**

**类中保存的指针，在这种情形下的类，其赋值运算符可以使用`swap`处理自赋值：**

```c
Class& Class::operator=(Class c)
{
    swap(*this,c); // 这里交换时将一个值形参中的指针都交换给了this，其在函数结束时自动析构。
    return *this;
}
```

---

##### 移动构造函数和std::move

例如vector的`reallocate`函数，我们重新分配时，通常不希望创建额外的对象，而是希望**直接移动对象。**

`move`函数包含在头文件`utility`中。

`newValue = std::move(value)`通过move**进行调用移动构造函数**，使用`move`时，应说明命名域，`std::move(value)`。**不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept。同时在声明和定义处都要标记noexcept，若是不声明，为了避免移动过程中出现异常导致失败，可能会使用拷贝构造，为了确定其使用移动构造函数，必须显式声明noexcept**

```c
MyClass(MyClass&& other) noexcept: mData(other.mData), mSize(other.mSize)
    {
    要声明noexcept来表明移动构造函数不会抛出异常，否则标准库会认为我们的类对象时可能会抛出异常。
        other.mData = nullptr;
        other.mSize = 0;
    }
// 移动构造函数的示例，在函数块中应该将other的所有值都绑定到this。
```

**移动复制运算符：**在拷贝构造函数的基础上，使用`&&`

###### 右值引用：

符号：`&&`。如：`int &&i = 1;`

在移动构造函数中，形参的对象类型就是`&&`。我们通过`move`将一个左值对象转换成可以绑定到右值引用上的右值。

###### 移动迭代器

移动迭代器的解引用运算符生成一个右值引用。通过`make_move_iterator()`将一个普通迭代器转化为移动迭代器，如`make_move_iterator(begin())`，甚至更复杂的可以搭配：`uninitialized_copy(make_move_iterator(begin()),...)`**通过移动迭代器进行的复制**。像这个例子，我们可以搭配算法使用移动迭代器。

###### 总结：通常说来

一个成员函数可以定义两个版本，一个参数是左值引用类型的拷贝版本，一个参数是右值引用类型的移动版本。

##### 左值和右值引用成员函数

通常在参数列表后`()[&|&&]{...}`可以定义为`&`或者`&&`引用限定符，**该限定符必须同时出现在定义和声明中。对于`&`限定的函数，只能将其返回值用于左值，对于`&&`限定的函数，只能将其返回值赋予右值。成员函数支持同时定义`const`和引用限定：`()const [&|&&]{}`**

c++支持某些右值赋值，如：`string s1,s2;s1+s2 = "dwad";`

```c
//本对象为右值，因此可以原址排序
Foo Foo:sorted()&
{
	sort (data.begin(),data.end());
	return *this;
}
//本对象是cost或是一个左值，哪种情况我们都不能对其进行原址排序
Foo Foo::sorted()const&{
	Foo ret (*this);
	//拷贝一个副本
	sort(ret.data.begin(),ret.data.end());
	//排序副本
	return ret;
	//返回副本
}
```

<font color="red">对于引用限定符的成员函数重载的规则，如果定义两个或两个以上相同名字的成员函数，要么对所有该相同成员函数都加上引用限定符，或者都不加</font>

---



##### 重载运算符

本质上是函数，名字格式`returnType operator符号(参数)`。**某些运算符，包括赋值运算符（返回值是一个类型的引用）必须定义为成员函数。**

参数的数量与运算的对象数量一样多，如果是成员函数，则第一个运算对象隐式绑定到`this`上。

会改变对象状态的一般要定为成员函数：如，`%`定**为非成员函数**，`%=`定**为成员函数**

<font color="red">输入运算符必须处理可能输入失败的情况`if(in){成功}`，而输出不需要</font>

**几个容易出错的：**

* 下标运算符返回值通常是**引用**，一般定义一个常量版本，和一个非常量版本。

* 前置运算符，返回值是**引用**；后置运算符，返回值是**值**。**为了区分前置和后置，通常在后置运算符重载的参数中添加一个不被使用的`int`参数**

  * 前置++通常先检查当前指针是否为`end`，再++。而前置`--`则先`--`再check当前指针是否`<0`为无效指针。**而后置运算符不需要检查**

* 箭头运算符通常通过调用解引用运算符重载，**返回解引用运算符的地址**。

  ```c
  type* operator->()const {
      return & this->operator*();
  }
  ```

* 调用运算符可以让类对象拥有像函数一样的行为，可以代替`lambda`，**我们可以向泛型算法中传递一个实例作为param。**。

  ```c
  void operator()(const string &s)const{os<<s<<sep;}
  /////////////////////////////////////
  PrintString printer;
  printer(s);
  for_each(vs.begin(),vs.end(),PrintString()) // 
  ```

* 类型转换运算符：`operator type()const{};`**负责将一个类转换成其他类型，**该运算符不需要显式的返回类型以及形参。**若类型转换定义了`explicit`则需要`static_cast`显式转换，通常我们需要定义向`bool`的转换

##### 继承

冒号后，紧跟以逗号分隔的基类列表，每个基类前面可以有访问说明符。

**派生类可以调用基类的初始化列表：`():baseClass(baseV1,baseV2),v1(...)...`**

* 如果想将某个类作为基类，**作为基类的类不能仅仅是声明，必须已经定义。**

* `final`--`class c final{}`表示该类不能被继承

* 基类必须定义虚构函数为**虚析构函数**。

* 当基类中显式的定义了拷贝、移动函数，则派生类会自动获得合成的相应函数。

* **在派生类中想要拷贝或者构造基类的部分，必须使用初始化列表显式的调用基类的相应构造函数，移动的直接通过`move`**

  ```c
  // Base
  D &D::operator=(const D&rhs) {
      Base::operator=(rhs); // 为基类部分赋值
      ...
  }
  ```

  

**纯虚函数：`=0`**

<font color="red">只有派生类共有的继承基类时，用户代码才能使用派生类向基类的转换</font>

---

###### 派生类修改成员访问权限

派生类可以修改自己能访问到的基类成员的权限，**包括函数以及变量**。

```c
方法：如基类中有void add();
派生类要修改为Private权限：
private:
	using Base::add;
// 修改的权限类型为该using前可找到的第一个访问说明符决定
```

###### 继承的例子分析

![image-20230419215353012](https://github.com/xxn-1/image/blob/main/img/202304192153141.png)

![image-20230419215439721](https://github.com/xxn-1/image/blob/main/img/202304192154795.png)

![image-20230419215953696](https://github.com/xxn-1/image/blob/main/img/202304192159801.png)

在整个继承层次中，**我们不会暴露这些类，而是重新定义一个接口类，其中定义`Query_base`的接口类，由其负责隐藏整个体系。`&`生成`AndQuery`对象，其他运算符类似**

如：`Query("fiery")|Query("bird")&Query("hello")`

##### 动态绑定

基类的引用和指针，派生类都可以赋值。

绑定到基类引用的派生类调用自己的函数；绑定到基类指针的派生类调用基类的函数

```c
#include <iostream>
using namespace std;
class Base
{
public:
    virtual Base *clone() &
    {
        cout << "copy";
        return new Base(*this);
    }
    virtual Base *clone() &&
    {
        cout <<"move";
        return new Base(std::move(*this));
    }
    virtual void show()
    {
        cout << "nihao";
    }
};
------
#include "Base.h"
using namespace std;
class BaseOver : public Base
{
public:
    Base *clone() &
    {
        cout << "copy";
        return new BaseOver(*this);
    }
    Base *clone() &&
    {
        cout << "move";
        return new BaseOver(std::move(*this));
    }
    void show() override
    {
        cout << "nnnnn";
    }
};
-----
int main() {
    BaseOver t;
    Base* base1 = t.clone();
    
    base1->show();
}
```



---

##### 交叉继承

通过虚继承解决十字交叉继承，避免重复拥有基类的对象。

`class c:virtual public cbase`

`class b:virtual public cbase`

`class d:public b,public c`

这样d就只拥有1份cbase的对象了



##### 嵌套类：

通常在类的内部public中声明，在类的外部定义。定义时需要通过类的作用于访问

##### 标准库定义的函数类型

标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的**模板类**。

**使用这些模板类可以使我们的程序更具有可移植性和类型无关的特性，结合我们定义的模板来编写函数**

**算术：**

* `plus`
* `minus`
* `multiplies`
* `divides`
* `modulus`
* `negate`

**关系：**

* `equal_to`
* `not_equal_to`
* `greater`
* `greater_equal`
* `less`
* `less_equal`

**逻辑：**

* `logical_and`
* `logical_or`
* `logical_not`
* 

#### 迭代器

迭代器要针对具体的容器类型<br/>

* `vector<int>::iterator it;string::iterator it;`支持读写的迭代器
* `vector<int>::const_iterator it;`仅支持读的常量指针

```c++
// begin() or end()
获取iterator类型
// cbegin() or cend()
获取const_iterator类型
// rbegin() or rend()
获取reverse_iterator类型 - 反向迭代器
// crbegin() or crend()
```

##### 类型

1. 插入迭代器，以下都是函数：

   * `back_inserter`借助push_back
   * `front_inserter`借助push_front
   * `inserter`借助insert，需要传入第二个参数，是一个迭代器

2. 流迭代器：绑定到输出或输入流，遍历IO流，使用时，需要创建两个迭代器，一个用于指定读入的流对象，另一个作为尾后迭代器

   * `istream_iterator<type>it(流对象)`
   * `istream_iterator<type>eof`作为尾后迭代器

   ```c++
   // 可以直接将流放到容器中
   istream_iterator< int > initer(cin),eof;
   vector< int > nums(initer,eof);
   // 或单独读出流中一个元素
   cout << *initer++;
   // 运用到泛型算法中
   accumulate(initer,eof,0);
   ```

   * `ostream_iterator<type> out_iter(cout," ")`其中接收一个输出流，第二个参数会在每次输出后默认输出一个" "。

    ```c++
   // 可以直接将流输出
   ostream_iterator< int > out_iter(cout);
   vector< int > nums;
   copy(nums.begin(),nums.end(),out_iter);
   // 或单独读出流中一个元素
   *out_iter = nums[0];
    
    ```

3. 反向迭代器

4. 移动迭代器：不拷贝元素，而是移动他们。

5. 



---

#### 异常

异常定义的几个头文件`exception`、`stdexcept`、`new`（包含bad_alloc异常）、`typeinfo`（包含bad_cast异常）

```c++
// stdexcept定义的几个异常
exception 最常见的问题
runtime_error 只有在运行时才能检测到的问题
range_error 运行时错误：超出有意义的范围
overflow_error 计算上溢出
underflow_error 下溢出
logic_error 程序逻辑错误
domain_error  参数对应的结果值不存在
invalid_argument 无效参数
length_error 超出该类型最大长度的对象
out_of_range 使用一个超出有效范围的值
```

* `throw 异常类型(信息);`
* `try`语句

```c++
try{

}catch(异常类型 e){

}catch(异常类型 e){

}
```

---

#### 类型转换

* `static_cast`常用于明确定义的强制类型转换，左值转右值也是允许的
* `dynamic_cast`将基类指针转化到派生类指针。
* `const_cast`改变底层const的转换
* `reinterpret_cast`

---

#### IO库

包含三个重要的头文件：  

1. `iostream`:用于读写流，包含  
   `istream/wistream`:读取|`ostream/wostream`:写入|`iostream/wiostream`:读写  
2. `fstream`:用于读写命名文件:  
   `ifstream/wifstream`:读取|`ofstream/wofstream`:写入|`fstream/wfstream`:读写  
3. `sstream`:用于读写内存对象string对象  
   `istringstream/wistringstream`:读取|`ostringstream/wostringstream`写入|`stringstream/wstringstream`读写<br/>
   流的状态有4种：`badbit(s.bad(),指出流已崩溃)/failbit(s.fail(),表示IO操作失败了)/eofbit(s.eof(),表示流到文件结束)/goodbit`。可使用位运算设置多种状态一次性。  
   其它的一些函数：`s.clear()/s.clear(status)清除指定的状态`  、`s.rdstate()`返回当前的状态。`s.setstate(status)`<br>
   刷新输出缓冲区的方法：<br>
4. `endl`输出换行并刷新  
5. `ends`输出一个空白字符，然后刷新缓冲区  
6. `flush`不附加字符的刷新  
7. `cout << unitbuf/cout << nounitbuf`设置任何输出后都立即刷新缓冲区  

##### 输入输出流之间的关联

> 当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。

通过`s.tie()`返回与当前输入流相关联的输出流。通过`s.tie(输出流的地址)`将输出流关联到此输出流，输出流地址为`nullptr`时表示输入流不再与其他流关联。

##### 文件打开的几种模式

这些模式放在命名域`ios_base::`下：  

1. in  
2. out  
3. binary  
4. ate打开的时候定位到文件末尾  
5. app每次写操作前都定位到文件末尾  
6. trunc丢弃打开前文件的内容  
   几个限制：

```c++
1. 只能对ofstream只能设置out，ifstream只能设置in
2. 只有设定为out后才能设置trunc
3. 没有设定trunc才能设定app
4. 默认情况以out打开文件会丢弃文件内容，需要指定app模式。
```

##### sstream

一些函数：  

1. `strm.str()`返回sstream保存的string，`strm.str(s)`将string s拷贝进sstream中。  

---

#### 容器

##### 顺序容器

`vector、deque、list、forword_list、array、string`  
顺序容器的几种类型别名：

1. iterator  
2. const_iterator  
3. size_type  
4. difference_type  
5. value_type  
6. reference  
7. const_reference  

> 容器初始化拷贝时，不通过迭代器的初始化都要求容器的类型相同。  
> 容器array的使用，除了定义类型，还要定义大小：`array<int,32>a;`

顺序容器适配器：`queue、priority_queue、stack`

```C++
// 适配器默认情况下queue和stack是基于deque实现的，而priority_queue是基于vector实现的
如：stack<int>s;
// 支持重载容器类型，通过设置第二个参数
stack<int,vector<int>>s;
// stack支持除array和forword_list之外的所有容器
// queue支持构造在list和deque上
// priority_queue支持构造在vector和deque上
```

##### 关联容器

* `map`:包含`.first、.second`两个成员，关键字不能修改，值允许。
* `set`值不能修改
* `multimap`
* `multiset`
* `unordered_map`
* `unordered_set`
* `unordered_multimap`
* `unordered_multiset`

>注意：这些有序容器的元素类型必须支持比较操作'<'，如list列表并不支持所以不能作为元素。
>这些容器可以重载比较运算符，我们需要传递一个重载的函数指针，以及具体的函数，如：

```C++
bool compareIs(const int &a, const int &b)
{
    return a > b;
}
vector< int > vs = {421, 12, 4321, 23, 5241, 211, 53532, 121};
set< int, decltype(compareIs) * > nums(vs.begin(), vs.end(), compareIs);
```

**这些关联容器的`insert`操作会返回一个`pair`类型，`first`是一个`map`迭代器位置，`second`是一个`bool`表示是否插入成功**

* `lower_bound`返回指向第一个具有给定关键字的元素
* `upper_bound`返回最后一个匹配给定的关键字的元素之后的位置
* `equal_range`返回一个pair，包含相等元素的首和尾迭代器

###### 无序容器

无需容器的桶策略

![][642e59e5a682492fcca021bee.png]  
不同关键字哈希后可能分配到相同的桶后，再顺序比较

**无序容器若想定义其类型为自定义类型，需要重载`==`运算符和哈希值计算函数**：

```C++
size_t hasher(const Student& stu) {
    return hash<string>()(stu.id); // 库函数
}
bool eq(const Student& stu1,const Student& stu2) {
    return stu1.id == stu2.id;
}
unordered_multiset<Student,decltype(hasher)*,decltype(eq)*>s(42,hasher,eq);
```



##### pair类型

* `pair<type1,type2>p;`
* 构造：`make_pair(v1,v2)`返回一个pair。

---

#### 泛型算法

大多数定义在头文件`<algorithm>`中，`numeric`定义了一些数值算法。[algorithm算法库][algorithm]。这些算法是支持不同容器中不同类型的比较的，前提是这些类型的比较是允许的。  
    泛型算法的特点:算法总是通过<font color="red">迭代器</font>操作容器，因此不能直接向/从容器添加、删除元素，无法改变容器大小。**泛型算法对于容器的要求并不是有足够的空间，而是有足够的元素。即.size()的大小要足够，因此对一个空容器调用reserve(n)也是不可以的；只能通过插入迭代器函数来完成改变元素个数的操作**

> sort算法是利用元素类型的“<”来实现排序的

##### 插入迭代器(back_inserter)函数

接受一个指向容器的引用，返回一个插入迭代器。向返回的插入迭代器赋值时，会调用`push_back`将该值插入到容器中。例子：

```C++
vector<int>vec;
fill_n(back_inserter(vec),10,0);//借助插入迭代器向和泛型算法fill_n向容器中插入10个0。
```

---

##### 谓词

某些泛型算法还有重载后的版本，接受第三个参数，此参数是一个**谓词**。本质是一个可调用的表达式，返回结果是一个能用作条件的值。谓词的类型共有两种：一元谓词、二元谓词。

>注意：谓词在泛型算法中只用写出谓词函数的名字，不用写实参。

---

##### lambda表达式

通常形式为:`[捕获列表](参数列表)mutable throw(类型)->返回类型{函数体};`  
捕获列表讲解：lambda通常只能访问使用外部的全局变量，而不能使用函数里的局部变量，因此需要捕获列表。[x,y,z]如上，三个局部变量补获后已经可以在lambda中使用了。捕获的方式分为：<br>

* 按值捕获:若按值捕获时想要修改变量的值，需要添加上`mutable`关键字。  
* 引用捕获`[&x,&y]`  
* 隐式捕获，包含：  
  &nbsp;&nbsp;1. `[=]`:函数局部作用域里的所有变量都按值捕获  
  &nbsp;&nbsp;2. `[&]`:函数局部作用域里的所有变量都按引用捕获  
  &nbsp;&nbsp;3. `[=, reference_list:]`:reference list里的变量按引用捕获，其余的变量按值捕获，比如 [=, &a, &b] 表示 a 和 b 按引用，其余按值捕获   
  &nbsp;&nbsp;4. `[&, identifier_list]`identifier list里的变量按值捕获，其余的变量按引用捕获，比如 [&, a, b] 表示 a 和 b 按值，其余按引用捕获  

使用：

```C++
auto f = []()->{return 3;}
cout << f() << endl;
```

---

##### bind函数

定义在`<functional>`头文件中  
可以将参数绑定在某个函数上，返回新的函数句柄。假如我们已经拥有函数test，`bind`函数有些特殊参数:`_1`、`_2`等等，若是使用这些参数，则会将调用函数f传来的形参传递给test调用，而bind还支持自己定义默认的参数绑定到test上。。`auto f = bind(test,_1,...)`

> 注意：这些占位符都放在`placeholders`命名空间中

但是若希望在bind函数中传递某些无法拷贝的值，就需要传递引用，因此可以借助`ref`或`cref`函数。如`ostream s;bind(test,ref(s))`

#### 智能指针

都定义在`<memory>`头文件中，以下智能指针都是模板，需要提供**类型**。

* `shared_ptr<type>`计数器为0时自动释放，**注意，不要使用一个智能指针get得到的指针去初始化另一个智能指针，这可能导致该指针分配的内存随时可能被delete。**

  ```c++
  shared_ptr<string>p
  if(p && p->empty) // 如果p指针不为空，且指向一个空string。
  shared_ptr<T> ptr(new T()); // ptr引用计数为0时，对象自动释放。
  ```

  * `p.get()`获得智能指针中保存的指针。
  * `make_shared<type>(参数)`使用指针初始化返回一个shared_ptr，这里参数并不限，比如说可以是`make_shared<int>(32)`指向一个int为32的指针。
  * `p.unique()`判断其引用是否为1
  * `p.use_count()`返回其共享对象的智能指针数量

  **自定义删除器：对于自己的类型，需要重载shared_ptr的删除器，方法为定义一个函数，函数参数为该类型指针，在函数中释放相关内存，初始化shared_ptr(变量，删除器)。注意跟unique_ptr有点不同，例子：`share_ptr<type>p(new type(),mydelete)`**

* `unique_ptr<type>`，该类型必须使用直接初始化的方式，并且要绑定到一个**new**的指针上，可以使用`p.reset(p1.release())`转移其唯一的所有权，该类型通常是不能拷贝或赋值的，但是也有特殊情况，即是在函数中作为局部变量返回时，返回该局部对象的拷贝

  ​	![image-20230409135506257](https://cdn.jsdelivr.net/gh/xxn-1/image/img/202304091355398.png	)

  自定义删除器：`unique_ptr<type,decltype(mydelete)*>p(new type(),mydelete)`

* `weak_ptr<type>`是一个不控制所指向对象生存期的智能指针，指向由一个`shared_ptr`管理的对象，将其绑定到一个`shared_ptr`不会改变该`shared_ptr`的引用计数器。**初始化需要**直接被一个`shared_ptr`对象赋值。**使用的途径：通常可以作为为一个容器类定义指针时，用来检查的指针。**

  * `lock()`
  * `reset()`
  * `expired()`
  * `lock()`如果指向的shared_ptr引用计数为0，返回空的shared_ptr对象，否则返回一个shared_ptr。

  ```c++
  shared_ptr<int> p(new int(3));
  weak_ptr<int>pp = p;
  if(p == pp.lock()) { 
      // 安全
  }
  ```

  

##### 动态内存

对于`new`的方式分配内存时，希望阻止其抛出异常，可以使用` ... = new (nothrow) type;`

##### 动态数组

标准库提供了一个特殊版本的`unique_ptr`管理这样的动态数组。`unique_ptr<int[]>up(new int[10])`，`up[i]`下标访问，`up.reset()`自动用`delete[]`释放。

`shared_ptr`与`unique_ptr`有所不同，要使用其管理动态数组，需要提供自己的删除器，并且不支持访问，必须使用get()函数获取原始指针。`shared_ptr<int>sp(new int[10],[](int*p){delete []p;};`**注意，这里的类型不是数组类型。**

###### allocator

传统的new会在分配内存时同时为分配的对象进行初始化，**但往往我们可能会一次性分配大量对象内存，同时可能只会使用其中一小部分，这个时候就需要将分配内存和初始化分开**

`allocator`类支持该操作。是一个**模板类**。

```c++
allocator<type>alloc;
auto p = alloc.allocate(n); // 分配n个未初始化的string
a.deallocate(p,n); // 释放p开始的n个类型为type的对象内存，在destory之后这段allocate的空间可以重新构造，若是不想使用这段空间，可以调用该函数，n等于allocate时的n，释放空间，今后将不能再构造初始化。
a.construct(p,参数列表); // 参数列表传递给p当前指向的对象构造函数初始化。
a.destory(p);  // 对p指向的对象执行析构函数，注意只需要对指针调用了construct的指针p执行该destory操作

释放时，推荐从尾向首释放
```

![allocator的伴随算法](https://github.com/xxn-1/image/blob/main/img/202304091552562.png)

#### 标准库

##### function

定义在`functional`中，使得我们可以方便的将**类形式函数调用，lambda形式调用，函数指针形式的调用**形式**使用统一的`function`模板保存，从而建立一个函数表，通过`map`**。如：

```c
function<int(int,int)>f1 = add; (add是一个int (int,int)的函数)
function<int(int,int)>f2 = divide();
function<int(int,int)>f3 = [](int i,int j);
f1(1,2); 即可调用
map<string,function<int(int,int)>>maps; // 函数表
```

##### invoke

std::function 适用于需要实际保留可调用对象以便稍后使用它的情况。std::invoke 用于当您需要立即使用该可调用对象而不存储它以备后用时使用。

#### 多线程

头文件：

* `thread`

* `mutex`

* `condition_variable`

* `future`

* `atomic`

* `semophore`

  

类型标识：

* `thread_local`

类型：

* `future<函数返回类型>(async(std::launch::async or deferred,函数名...))`第一个参数是策略表示立即启动还是延迟，延迟后通过`.get()`函数启动，获取async执行函数的返回结果

* `shared_future<返回类型>f(async(...))`该线程可以被多个线程利用，可以多次调用其内函数。

  ```c++
  std::shared_future<int> f = std::async(func1);
  	auto f1 = std::async(addOne, f);
  	auto f2 = std::async(addOne, f);
  
  	f1.get();
  	f2.get();
  ```

* `thread`

* `this_thread`

* `promise`

* `promise`可以使线程间通信，传递数据，完成同步。

* `packaged_task`可以自由控制线程启动时间的一个线程函数

* `mutex`

* `recursive_mutex`可重入锁

* `time_mutex`定时锁

* `recursive_time_mutex`定时可重入锁

* `lock_guard`

* `unique_lock`类似于`lock_guard`，但用法更丰富

* `condition_variable`条件变量，必须结合`unique_lock`使用

* `condition_variable_any`可以结合任何锁

* `atomic<类型>`

* `counting_semaphore`非负资源计数的信号量

* `binary_semaphone`拥有第二个状态的信号量

接口：

* `async(函数,...参数列表)`将获取到的函数立刻在一个新的线程异步启动

##### 协程



#### __attribute__属性

#### 模板

##### 函数模板

**函数声明需要声明模板参数，但允许不定义。**

* 模板类型参数：`template <typename T,typename T1...> 类型 func(...){}`

* 非模板类型参数：`template<typename T,int SIZE>test{cout << SIZE;}||test<int,5>(形参)`在尖括号内可以添加非类型参数，**其值必须为常量值**。**通常可以用来获得容器中的元素个数，编译器会在编译时期用数组的长度初始化N**

  ```c
  template<typename T,size_t N>
      void print(const T (&a)[N])
  {
      
  }   
  ...
  int a[2] = {1,2};
  print(a);
  //////////////////////////////////////
  #include "iostream"
  using namespace std;
  template <typename T,size_t N>
  void getSum(const T (&a)[N])
  {
      cout << N << endl;
      T sum;
      for(auto x:a){
          sum += x;
      }
      cout << sum << endl;
  }
  int main() {
      int a[2] = {2,3};
      getSum(a);
      string b[2] = {"dfwsefd","fre222"};
      getSum(b);
  }
  ```

  

* `inline`和`constexpr`的函数模板，这两个关键字必须放在模板参数列表尖括号后，返回类型之前。

##### 类模板



```c
template <typename T,...> class 类名
{
    
}
```

**特例化：**

```c
template <> class 类名<int> {
};
// 特例化int
```

定义的模板成员函数：

```c
template <typename T> Blob<T> Blob<T>::func(...)
    // 凡是有类类型出现的地方，都要给出<T>
```

**通常情况下，static成员变量需要定义为模板，**

```c
template <typename T,...> class Foo
{
 	static std::size_t count;   
}
template <typename T> size_t Foo<T>::count = 0;
```



----



如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例，如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。

* 一对一：`friend type func<T>()||friend class B<T>;`
* pal的所有实例都是当前类友元：`template<typename X>friend class pal;`
* 模板参数成为友元：`friend T;`

##### 模板类型别名

`template <typename T,...> using alias = map<T,int>`

`alias<int> == map<int,int>`

##### 显式类型声明

对下函数，必须显式声明模板参数类型，因为模板在遇到参数列表前都无法推导其类型，其中每个参数类型用逗号分割，同时可以仅声明其中一部分。

显式声明下，可以使得其他类型的参数使用隐式的转换调用该实例模板函数。

```c
template <typename T1,typename T2,typename T3>T1 f(T2 t2,T3 t3){
	return ...
}
f<int>(1,2);
```

##### 尾置返回

因为模板在遇到参数列表前都无法推导其类型，故返回值类型无法确定。因此必须借助尾置返回，将返回值声明为auto

```c
template <typename T>auto get(it begin,it end)->decltype(*begin){
	return *begin;
}
```



**一般情况下都使用迭代器操作，然而迭代器只能返回引用类型，若想返回值需要借助`type_trait`头文件中类型模板操作**

> 注意：声明模板类型参数的类型参数时，要显式的在其前面表明`typename`，如下：

```c
template <typename T>auto get(it begin,it end)-> typename remove_reference<decltype(*begin)>::type
{
	return *begin;
}
```

##### 一些算法

* `std::is_same_v<T,type>`判断模板参数T，是否为某种类型type，如int。

##### 模板实参推断

针对不同的模板参数类型，如下：

* `T&`只能绑定到一个左值，或一个引用类型。不能绑定一个**常量值**。

* `const T&`可以绑定到一个左值，一个临时对象或者一个字面值常量

* `T&&`支持传递任意类型，如果绑定一个左值，**会推导为左值引用**。如`int`，会被推导为`int&`。可以使用`remove_reference`去引用。

  

---



* **引用折叠规则：**针对模板参数类型为引用，实参类型也为引用，其构成如下几种：假设前面的引用代入的是模板的参数，后面的引用为实际的参数类型，会发生折叠

  * `X& &`折叠为`X&`
  * `X& &&`折叠为`X&`
  * `X&& &`折叠为`X&`
  * `X&& &&`折叠为`X&&`

  例子：

  ```c
  template<typename T>void test(T &&)
  test<int&>;
  则参数类型为：int& &&，折叠为int&
  ```

##### 模板类型约束

通过约束可以使得不同的类型实现不同的操作，从而定义多个同名函数不同约束条件

###### c++20关键字约束实现

###### 库模板enable_if实现

```c
// 借助type_trait中模板
template<typename T>
typename enable_if<is_same_v<T, string>::/*这里写对T的约束模板 */, .../*这里写实际的返回类型*/>::type ToString(T t)
```

###### 自定义type_trait

其思想本质是通过模板类型特例化实现，首先通过模板类型将所有类型继承`false_type`，而后将自己需要通过的类型特化

如判断是否为浮点数，

```c++
template <typename>
struct is_floating_point : false_type {};
template <>
struct is_floating_point<float> : true_type {};
template <>
struct is_floating_point<double> : true_type {};
template <>
struct is_floating_point<long double> : true_type {};
```

**需要注意的是上面这种方法实现后，对于`const`和引用类型都是无法通过的，所以改进后**

```c++
// 基础判断降级为helper
template <typename>
struct is_floating_point_helper : false_type {};
template <>
struct is_floating_point_helper<float> : true_type {};
template <>
struct is_floating_point_helper<double> : true_type {};
template <>
struct is_floating_point_helper<long double> : true_type {};
template <typename T>
struct is_floating_point : is_floating_point_helper<typename remove_const<typename remove_reference<T>::type>::type> {};
```



##### 转发

某些情况下需要完成连同实际类型的转发，去其他函数完成实际操作，**就需要定义能保存类型信息的函数参数，必须要借助`std::forward<T>()`函数，同时必须定义模板中的函数参数为右值引用类型，其中T为模板参数的类型**

```c
template<typename F,typename T1,typename T2>void file(F f,T1 &&t1,T2 &&T2){
    f(std::forward<T1>t1,std::forward<T2>t2);
}
void f(int v1,int &v2);
// f中的v1为值传递，v2为引用传递。
要完成这一操作，我们需要借助forward函数。
```

##### 可变参数模板

`sizeof...(模板参数名or函数参数名)`可以返回包中元素数量的关键字，一般来说若是参数类型相同可以使用`initializer_list`来完成，但是不同时，我们就必须借助可变参数来完成。



###### 模板参数可变

`template<typename T,typename...Args>void test(const Args& ... args)`如果一个模板参数可变，则函数参数一定可变。

###### 函数参数可变

**可变参数模板是递归进行的，在定义可变参数模板前，必须定义其函数的单个版本作为边界结束，且该版本必须在可变版本之前**

传递可变函数参数时，语法为：`func(args...)`

例子：

```c
template<typename T>ostream &print(ostream& os,const T&t){
    return os<<t;
}
template<typename T,typename... Args> ostream &print(ostream& os,const T&t,const Args...rest){ 
    // 可变函数版本中，一般一定要定义一个不可变的函数参数来消耗可变参数
    os<<t<<",";
    return print(os,rest...);
}
```

###### 扩展

在可变参数模板中的参数通过`...`省略号进行扩展

注意：`debug(rest)...`≠`debug(rest...)`

```c
return print(os,debug(rest)...)
    等价于
return print(os,debug(rest1),debug(rest2),...)
```

****

###### 可变参数模板中的转发

`std::forward<Args>(args)...`



##### 特例化函数模板

```c
template<> 函数体
```

##### `iterator_traits`

该类是一个模板类，可以获取迭代器的特质信息

```
template <class T>
struct iterator_traits<T*>
{
  typedef random_access_iterator_tag iterator_category;
  typedef T                          value_type;
  typedef ptrdiff_t                  difference_type;
  typedef T*                         pointer;
  typedef T&                         reference;
};
```

#### 位域

```c
union {
        struct
        {
            unsigned char a1:2;
            unsigned char a2:3;
            unsigned char a3:3;
        }x;
        unsigned char b;
}d;
d.b=100
    
```

#### 异常

异常发生时，其中的对象会自动的析构。因此，**一般我们将资源类放入类中，使其自动的析构**

异常具有继承关系时，我们通常catch异常的引用，而且越是特例化则该catch越放在前面。

###### 重新抛出

某些情况下，需要将该异常再往上抛出一层。

则在catch中，**仅使用`throw;`即可**：

```c
try{
    
}catch(... e){
    throw;
}
```

###### 捕获所有异常

`...`可以匹配所有异常

###### try语句块

try函数块的应用场景一般局限于下面几个：

（1）构造函数初始化列表；

（2）基类构造含数据；

（3）析构函数；

```c
struct A : public B
{
    A() try : B(), foo(1), bar(2)
    {
        // constructor body
    }
    catch (...)
    {
        // exceptions from the initializer list are caught here
        // but also rethrown after this block (unless the program is aborted)
    }
 ////////////
    ~A()
    try
    {
        // destructor body
    }
    catch (...)
    {
        // exceptions from the destructor are caught here
        // but also rethrown after this block (unless the program is aborted)
    }
private:
    Foo foo;
    Bar bar;
};
```

###### noexcept

该关键字表明函数不会抛出异常

接收一个可以转化为(bool)的参数，为true表明不会抛出异常，否则表明可能会抛出异常

#### 命名空间

###### 内敛命名空间

嵌套的命名空间中，在外层的空间不支持直接访问内层空间变量。但是使用内联命名空间，外层命名空间就可以直接使用内层中的变量，不再需要使用命名域。

`inline namespace n{}`

通常作用于版本更迭，旧版本代码放入非内联命名空间中，新版代码放入内联命名空间中：

```
namespace xxx{
	#include "v1"
	#include "v2"
}
v1是非内联的，必须使用xxx::v1::对象
v2是内联的，可以使用xxx::对象。
```

###### 未命名空间

`namespace{}`该命名空间中定义的变量为静态生命周期，在程序开始创建，结束时销毁，其中的变量可以直接使用

###### 命名空间别名

`namespace 别名 = 命名空间名字`

###### using引入

#### 特殊机制使用

##### 控制内存分配

**自定义new和delete：`operator new|new []|delete|delete[]`**

对new[[]]的返回值必须是`void *`，第一个形参必须为`size_t`，且不能有默认值。我们自定义的new,delete可以传入额外的参数，以定位的形式，将实参传给新增的参数。

```c
void *operator new(size_t, int);
// void *operatoe new(size_t,void *)形式已经被标准库使用不能被重载。该版本new(内存) b;使得我们可以在一个指定的内存地址分配
new(3) a;
```

对delete[[]]的返回值必须是`void*`，第一个形参类型必须是`void*`，当讲delete**定义为类的成员函数时，可以包含另外一个参数`size_t`类型，其初始值为所指对象的字节数**

---

例子：我们要通过`cstdlib`中的`malloc`和`free`来分配释放

```c
void *operator new(size_t size)
{
	if(void *mem = malloc(size))return mem
    else return bad_alloc();
}
delete(void* mem){
    free(mem);
}
```

###### 链接指示

声明一个非C++函数：

```c
extern "C" { // 如使用python，则标明extern "python"
    // c
}
extern "C" void (func*)(); // c函数指针

#ifdef __cplusplus
	//	C++程序时才使用
extern "C"	
#endif
```



#### RTTI

##### typeid运算符

##### type_info

#### 枚举

**不限定作用域的枚举：`enum e{}`**可以直接在其它作用域调用`xx`

**限定作用域的枚举：`enum class e{}`**使用时`e::xx`

显式声明枚举类中每个枚举变量的类型：`enum e:int{}`



#### C++算法

算法库：[ | Microsoft Learn](https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm?view=msvc-170)

数值算法库：[ | Microsoft Learn](https://learn.microsoft.com/zh-cn/cpp/standard-library/numeric?view=msvc-170)

谓词：[ | Microsoft Learn](https://learn.microsoft.com/zh-cn/cpp/standard-library/functional?view=msvc-170)

#### C++11新特性

##### tuple

类似pair，每个`tuple`的成员类型都不相同

* `tuple<T1,T2,...>t(v1,v2,...)`其中v1的类型是T1，v2的类型是t2，以此类推
* `make_tuple(v1,v2,...)`
* `get<pos>(t)`t是一个tuple对象，返回t中pos位置处元素的引用。
* `tuple_size<tuple对象>::value`返回对象中元素数量
* `tuple_element<pos,tuple对象>::type`返回对象pos位置处成员的类型

##### bitset

初始化

* `bitset<比特位数>b`b是比特位数个0
* `bitset<n>b(u)`b是ull类型u的低n位的拷贝，若n超出ull最长位数，高位全补0
* `bitset<n>b(s,pos,l,zero,one)`b是s从pos开始l个字符的拷贝

##### 正则表达式

头文件：`regex`相关组件：**一些标志作为枚举值定义在`    std::regex pattern("",regex_constants::multiline);`**

* `regex(...,regex::icase|...)`表达一个正则表达式，忽略大小写
* `regex_match`将一个字符序列与正则表达式匹配
* `regex_search`寻找第一个与正则表达式匹配的子序列
* `regex_replace`
* `sregex_iterator`调用regex_search遍历string中所有匹配的子串
* `smatch`保存在string搜索的结果，为一个容器
* `ssub_match`string中匹配的子字符串结果

`R"正则表达式字符串"`定义正则表达式字符串时使用前缀R表明不再进行转义。

```c++
string str = "Hello_2021";
	smatch result; // 保存结果
	regex pattern("(.{5})_(\\d{4})");	//匹配5个任意单字符 + 下划线 + 4个数字

	if (regex_match(str, result, pattern))
	{
		cout << result[0] << endl;		//完整匹配结果，Hello_2018
		cout << result[1] << endl;		//第一组匹配的数据，Hello
		cout << result[2] << endl;		//第二组匹配的数据，2018
		cout << "结果显示形式2" << endl;
		cout << result.str() << endl;	//完整结果，Hello_2018
		cout << result.str(1) << endl;	//第一组匹配的数据，Hello
		cout << result.str(2) << endl;	//第二组匹配的数据，2018
	}
```



##### 随机数

`random`头文件

随机数库的组成，随机数引擎(生成)、随机数分布器(确定随机数范围)。

随机数引擎的常见操作：

* `XXXEngine e`
* `XXXEngine e(s)`使用整型值s作为种子
* `e.seed(s)`
* `e.min()`||`e.max()`引擎可生成的最小和最大值
* `e.discard(u)`将引擎推进`u`步，u为`ull`类型

**随机数引擎一般要传入分布器来使用**

常见引擎：

* `default_random_engine `
* `linear_congruential_engine` LCG线性同余法随机数生成器
* `mersenne_twister_engine`梅森旋转随机数生成器
* `subtract_with_carry_engine`带进位减法随机数生成器

```c
引擎适配器
discard_block_engine
independent_bits_engine
shuffle_order_engine

带参数的引擎适配器
minstd_rand		乘数为48271，模为214783647
minstd_rand0	乘数为16807，模为214783647
mt19937	32无符号梅森螺旋生成器
mt19937_64 64位
ranlux24_base  32位无符号借位减法生成器
ranlux48_base  64位
ranlux24	块大小223，旧块大小23
ranlux48	块大小389，旧块大小23
knuth_b

```

---

**常见的分布：**

```c

均匀分布     
             uniform_int_distribution        整型
             uniform_real_distribution       浮点型
 
伯努利分布    
              bernoulli_distribution         布尔,给定概率p生成true
              binomial_distribution          整型，采样大小t，概率p
              geometric_distribution         整型，每次实验成功的概率p
              negative_binomial_distribution 整型，k次试验成功的概率p
泊松分布
              poisson_distribution           整型，均值为x
              exponential_distribution       浮点型，指数分布，参数lambda
              gamma_distribution             浮点型，aloha为a，beta为b
              weibull_distribution           浮点型，形状参数为a，尺度参数为b
              extreme_value_distribution     浮点型
正态分布
              normal_distribution            浮点型，均值m，标准差s
              lognormal_distribution         浮点型
              chi_squared_distribution       浮点型，自由度x
              cauchy_distribution            浮点型，位置参数a，尺度参数b
              fisher_f_distribution          浮点型，自由度m和n
              student_t_distribution         浮点型，自由度n
抽样分布
              discrete_distribution          整型
              piecewise_constant_distribution浮点型
              piecewise_linear_distribution  浮点型

```

##### IO流控制

**接收参数的操作符都定义在`iomanip`头文件中**

操作符，类似于`endl`可以直接输出来改变IO状态的一种操作，并且分为带参数和不带参数：

**可以控制输入流或者输出流**

* `boolalpha||noboolalpha`使用该操作符，可以改变bool值的格式，使得输出1|0时只会输出true|false
* `hex`输出十六进制，`oct`十进制，`dec`八进制。以上三个操作符只影响输出整数时。`showbase||noshowbase`输出时显式表明整形输出的进制，如：0x。`setbase(n)`将整数输出为n进制。
* `setprecision(n)`设置输出的小数位数为n位。
* `showpos||noshowpos`非负数显示`+`
* `showpoint||noshowpoint`浮点数只有当包含小数才显示小数点
* `uppercase||nouppercase`打印`0x`还是`0X`
* `left`||`right`||`internal`在值的左侧添加填充符，在值和符号中间添加。
* `fixed`浮点数显示为定点十进制
* `scientific`显示为科学计数法
* `hexfloat`浮点数显示16进制
* `defaultfloat`重置为默认格式浮点数
* `unifbuf||nounifbuf`每次输出后都刷新缓冲区
* `skipws||noskipws`输入运算符跳过空白符
* `flush`刷新缓冲区

----

一下常用于按列打印时的格式控制对其

* `left`||`right`||`internal`默认空格补白，可以设置`setfill('单字符')`控制符来替换补白字符
* `setw`设置对齐格式后，要搭配`setw(n)`设置**读或写**中每个输出占用n个字符位置。

###### 未格式化输入输出

**单字节操作**

* `is.get(ch)`读取下一个字节放入ch，返回is
* `os.put(ch)`将ch输出到os
* `is.get()`返回下一个字节作为int
* `is.putback(ch)`将ch放回is返回
* `is.unget()`is向后移动一个字节
* `is.peek()`将下一个字节作为int返回，但不从流中删除，流仍处于原状态

**多字节操作：**

* `is.get(sink,size,delim)`is读取size字节，保存在sink给出的字符数组中，直到碰到delim字符截至或读完size个字节或遇到文件尾
* `is.getline(sink,size,delim)`与前一个get函数相似，碰到delim截至。但会多读取一位delim并丢弃delim
* `is.read(sink,size)`读取最多size个字节放入sink返回
* `is.gcount()`返回上一个读取操作从is读取的字节数
* `os.write(source,size)`将数组source中size个字节写入os
* `is.ignore(size,delim)`读取并忽略最多size个字符，包括delim

###### 流随机访问

* `tellg()`||`gellp()`返回一个输入流tellg或输出流tellp的当前位置
* `seekg(pos)`||`seekp(pos)`在一个输入流或输出流将标记重定位到pos位
* `seekp(off,from)`||`seekg(off,from)`将标记重定位到from之前或之后off个字符

##### type_trait头文件

包含了许多类型相关的模板，常用于模板中的类型转换，使用时一般要结合`typename`显式声明这是模板参数

https://blog.csdn.net/wxj1992/article/details/122506368

`iterator`头文件

* `iterator_traits`
* `char_traits`
* `numeric_limits`

---

* `re

#### C++14新特性

##### 返回类型支持auto

同时可以定义模板的返回类型为`auto`

##### 变量模板

```c
template <class T> T pi = T(初始化值);
使用：pi<int>;
```

##### lambda

* 支持对捕获的变量赋值：`[x=1]()...`
* 支持lambda函数中形参列表的类型定义为：`auto`

##### [[deprecated("提示的消息")]]标记

在函数上直接使用即可

##### 二进制字面量

以`0b`开头，可以使用`'`单引号作为数位分隔符。

```c
int a = 0b0000'0000'0010;这个二进制字面量会转变为2。
```

##### std::exchange

新增该接口，包含在头文件`utility`中，`exchange(v1,v2)`，会将v2的值赋给v1，同时不会改变v2的值

##### make_uniqued

##### 读写锁

通过

* `std::shared_timed_mutex`
* `std::shared_lock`

##### 字面量后缀

```
C++14 标准库定义了以下字面量后缀：
 “s”，用于创建各种 std::basic_string 类型。
 “h”、“min”、“s”、“ms”、“us”、“ns”，用于创建相应的 std::chrono::duration 时间间隔。
```



#### C++17新特性

[algorithm]: https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm?source=recommendations&view=msvc-170
[642e59e5a682492fcca021be.png]: https://pic.imgdb.cn/item/642e59e5a682492fcca021be.png
[642e59e5a682492fcca021bee.png]:https://pic.imgdb.cn/item/642e59e5a682492fcca021be.png

##### lambda

* 支持在抓捕中抓捕`*this`获得当前对象的一个拷贝

##### 类型推导语法

添加上后，使得模板可以自动推导类型不用写尖括号。



##### std::invoke

std::function 适用于需要实际保留可调用对象以便稍后使用它的情况。std::invoke 用于当您需要立即使用该可调用对象而不存储它以备后用时使用。它们都抽象了调用语法，但是以不同的方式进行。std::function 更重量级，因为它需要一种方法来统一存储所有这些不同类型，而 std::invoke 如果使用得当则没有开销，因为它只是根据可调用对象的类型选择语法。

`invoke(函数指针,函数需要的参数...)`

###### std::invoke_result



##### 结构化绑定

以下拿`[a,b]`举例，事实上，结构化绑定可以一次绑定更多`[a,b,c,...]`，

```c
for(auto [k,v]:maps);
/////////////////////
struct M{
    int a;
    int b;
}s
auto [u,v] = s;
auto &[u,v] = s;
```

##### 带初始化的if、switch

```c
if(bool f = false;f){}
switch(bool f = false;f){}
```

##### 类中static变量直接初始化

先前，类中static变量初始化必须在类内声明，类外定义。17中，支持使用`inline`关键字，直接在定义时初始化

`inline static int a = 3`

---

C++17 之前，全局变量只能在 cpp 文件中定义，然后在头文件中声明。如果在头文件中定义，并且该头文件被 include 到多个 cpp 文件，那么编译器会报重复定义错误。C++17 可以直接在头文件里通过inline来定义全局变量，即使该头文件被多次include，也不会报重复定义的错误。

```c
// .h 文件
#include<xxx.h>
inline MyClass myGlobalObj; // 即使被多个 cpp 文件包含也 OK
```

##### 聚合体初始化

**支持派生类的聚合体初始化**

```c
struct MoreData : Data {
    bool done;
}
MoreData y{{"test1", 6.778}, false}; // {"test1", 6.778} 用来初始化基类，不需要定义构造函数也可以使用

```

##### 新增的属性

* `[[fallthrough]]`用在某个`case`语句中，避免不写break报警告。
* `[[nodiscard]]`使得函数在返回值未被使用时报警告。可以使用参数版本`[[nodiscard("msg")]]`
* `[[maybe_unused]]`使用在形参列表中不想报警告的变量前，可以在形参未被使用时不会发出警告。或者使用在变量定义前，该变量未被使用时不会发出警告。

##### 嵌套命名空间

以前：

```c
namespace A {
    namespace B {
        namespace C {
            ...
        }
    }
}

```

现在：

```c++
namespace A::B::C {
    ...
}

```

##### u8字符串常量

`char c = u8'6'; `UTF-8 编码的字符 '6'

##### 预处理指令增加

检查某个头文件是否存在

```c
__has_include ("文件名")
__has_include (<文件名>)
    
#if __has_include(<Windows.h>)
    #define WINDOWS_FLAG 1
#else
    #define WINDOWS_FLAG 0   
#endif

```

##### if constexpr语句

```c++
 if constexpr (std::is_pointer_v<T>)
        return *t;
else if constexpr(...)
    else
        return t;
```

编译器在编译期决定使用`if`语句的哪部分，未使用的部分不会生成代码。但是语法检查还是会进行的。

##### 新的标准库组件

###### std::optional<>

让函数返回一个对象，错误情况下，返回空

**能用 `std::nullopt` 创建任何类型空的 std::optional** 

```c
std::optional<int> asInt(const std::string &s) {
    try {
        return std::stoi(s);
    } catch(...) {
        return std::nullopt; // 返回一个空的 std::optional
    }
}
if (oi) { // 判断是否有值
    cout << *oi << endl;
} 
```

###### std::variant

类似union，**更加强大，支持更多的类型，如string。**

```c++
  std::variant<int, std::string> var{"hi"}; // 可以持有 int, std::string 两种类型的值，初始化为 std::string
    std::cout << var.index();                 // 打印出 1
    var = 42;                                 // 现在持有 int 类型
    std::cout << var.index();                 // 打印出 0
    
    try {
        int i = std::get<0>(var);                     // 通过索引访问
        std::string s = std::get<std::string>(var);   // 通过类型访问（这里会抛出异常）
        ...
    } catch (const std::bad_variant_access& e) {      // 当索引/类型错误时进行处理
        std::cerr << "EXCEPTION: " << e.what();
        ...
    }
    
    // get_if
    // get_if<T>     返回指向类型为 T 的值的指针或 nullptr
    // get_if<Index> 返回指向索引为 Index 的值的指针或 nullptr
    std::string* s = std::get_if<std::string>(&var); // s == nullptr


```

###### std::any

`std::any`可以存储任何类型的单个值，可用来替代void*，any析构时可以自动析构管理的对象的，any可以存储类型信息，void\*不可以。

```c++
std::any a;               // a 为空
std::any b = 4.3;         // b 有类型为 double 的值 4.3
a = 42;                   // a 有类型为 int 的值 42
b = std::string{"hi"};    // b 有类型为 std::string 的值 "hi"
为了访问内部的值，必须使用std::any_cast<>将它转换为真正的类型：
auto s = std::any_cast<std::string>(a);
也可以对std::any对象的地址进行转换，如果转换失败，将返回std::nullptr。

auto p = std::any_cast<std::string>(&a);
if (p != nullptr) {
    ...
}




```

###### std::mutex

###### std::string_view

可以将一个字符串传输给string_view，**仅支持查看字符串，性能更高。**

###### std::apply

将容器的值当作函数的输入

##### 文件系统

```c++
namespace fs = std::filesystem;
fs::path pathToShow("/home/lzl/Desktop/execise");
cout << "exists() = " << fs::exists(pathToShow) << "\n"
<< "root_name() = " << pathToShow.root_name() << "\n"
<< "root_path() = " << pathToShow.root_path() << "\n";
namespace fs = std::filesystem;

// 创建目录
fs::create_directory(fs::path("tmp/test"));

// 创建目录树
fs::create_directories(fs::path("tmp/test/subdir"));

// 拷贝文件
fs::copy_file(src, dst, fs::copy_options::skip_existing);

// 判断文件是否存在
bool is_exist = fs::exists(filename);

// path 代表一个文件系统路径
std::filesystem::path p{"c:\\1.txt"};

// 路径 p 是普通文件吗？
if (is_regular_file(p)) {
    std::cout << file_size(p) << " bytes";
}

// 路径 p 是目录吗？
if (is_directory(p)) {
    for (auto& e : std::filesystem::directory_iterator{p}) { // 遍历目录
        std::cout << " " << e.path() <<;
    }
}

```

##### STL try_emplace

原先的`emplace`插入函数会无时无刻构造对象

而通过`try`仅在需要构造时才付出构造函数代价

##### STL并行算法库

**参数包含在头文件：`#include <execution> `**

重载的算法和新增的算法都支持指定一个所谓执行策略(execution policy)的参数,通过调整这个参数,你可以指定算法是以串行,并行或者矢量并行的方式来运行.

新引入的7个算法：

```c++
std::for_each_n

std::exclusive_scan
std::inclusive_scan

std::transform_exclusive_scan
std::transform_inclusive_scan

std::parallel::reduce
std::parallel::transform_reduce

```

```c
sort(execution::par, begin(numbers),end(numbers));
增加了：execution::par
```

辅助类型

`make_...`支持了一些列转换，如无符号和有符号之间的安全转换

#### C++20新特性

[v2-136b464518f1e7e2474592e485ca65c4_720w.webp (720×862) (zhimg.com)](https://pic1.zhimg.com/80/v2-136b464518f1e7e2474592e485ca65c4_720w.webp)

**四大模块：**

* Modules：不需要再分.h和.cpp
* Concepts：方便写出编译期表现出大部分特性和限制的模板
* Ranges：改变了使用算法和其组合的方式
* Coroutines：可以用异步的代码写出同步的效果。

---



* C++20增加了很多在其他语言看起来应有的东西：自动合并可中断的线程，信号量，[锁存器](https://so.csdn.net/so/search?q=锁存器&spm=1001.2101.3001.7020)，屏障，可等待通知的原子类型，原子引用，线程安全的原子智能指针。加上之前就有的各种并发支持：各种锁(唯一锁，等待锁，递归锁)，线程，条件变量，异步，任务包。

##### 模块

在

**优点**

- 代替头文件
- 声明实现仍然可分离, 但非必要
- 两模块内可以拥有相同名字
- **预处理宏只在模块内有效**
- 模块只处理一次
- 不需要防卫式声明
- 模块引入顺序无关紧要
- 所有头文件都是可导入的

---

* 使用`import 模块名`导入

* 创建时右击新增，有模块。模块后缀为`ixx`

* `export module 模块名`暴露给外界的模块名以供引用

* ```c++
  export {
      
  }
  // 导出代码块
  export namespace as{
      
  }
  ```

* 

---

分区：分区的名称必须由模块名称开头，后跟冒号 。如

* 主模块：`export module Example`只有主模块中的声明可以被源文件使用。**模块名字可以使用`.`分割没有其他含义，仅表示命名域分割**，一般在主模块`export import 各分区模块`

* 分区接口文件：`export module Example:part1`
* 分区实现文件：`module Example:part1`
* **分区或主模块访问另一个分区的接口必须导入，导入时只能使用冒号开始的分区名：`import :part2;`**

* `

通过将 C++ 标准库作为模块导入（而不是通过头文件包含它），可以根据项目的规模加快编译时间。 实验库拆分为以下命名模块：

- `std.regex` 提供标头 `<regex>` 的内容
- `std.filesystem` 提供标头 `<filesystem>` 的内容
- `std.memory` 提供标头 `<memory>` 的内容
- `std.threading` 提供标头 `<atomic>`、`<condition_variable>`、`<future>`、`<mutex>`、`<shared_mutex>` 和 `<thread>` 的内容
- `std.core` 提供 C++ 标准库中的任何其他内容

---

名称通过几种方式对模块使用者可见：

- 将关键字 `export` 放在要导出的每个类型、函数等的前面。
- 例如，如果将放在 `export` 命名空间前面， `export namespace N { ... }`则会导出大括号中定义的所有内容。 但是，如果在模块中的其他位置定义 `namespace N { struct S {...};}`，则 `struct S` 不可用于模块的使用者。 它之所以不可用，是因为命名空间声明不在 `export` 的前面，尽管有另一个同名的命名空间在前面。
- 如果不应导出类型、函数等，则省略 `export` 关键字。 它将对属于模块的其他文件可见，但对模块的导入程序不可见。
- 使用 `module :private;` 标记专用模块分区的开头。 专用模块分区是模块的一部分，其中声明仅对该文件可见。 它们对导入此模块的文件或属于此模块的其他文件不可见。 将其视为文件本地静态部分。 此部分仅在文件中可见。
- 若要使导入的其它的模块或模块分区可以被源文件使用，请使用 `export import`。 下一部分提供了一个示例。
- **注意预编译相关的例如#include必须包含在`module;`下方**

---

###### 模块的实现

注意，`ixx`的文件，只用来作声明，实现需要`cpp`，实现时不需要再使用`export`

要实现模块，需要注意命名也对应，如`export module example:part1`对应的文件`module example:part1`。**格式如下：**

```c++
module;

全局模块片段。 它位于命名模块的代码的前面，你可以在其中使用预处理器指令，例如 #include。 全局模块片段中的代码不由模块接口拥有或导出。

module example:part1;
```

##### 范围库

代表一组元素，类似迭代器对。原先的迭代器可能在进行某些操作时会失效，但是使用范围库就可以避免。**范围视图是惰性的**

头文件`ranges`，其中包含范围和视图，将范围作用于视图对象。**视图对象可以通过`|`运算符连接其他的视图对象，注意容器本身对象也是视图对象**

```c++
namespace ranges = std::ranges
namespace views = std::ranges::views
```

* `auto result = ranges::take_view(容器,n)`返回前n个元素视图，`for(auto v:result){}`获得元素
* `auto result = 容器对象|views::take(n)|...`
* 当然还可以结合视图和范围中一些算法来应用于每个元素
* 范围的算法：`range::sort(v容器对象|views:reverse)`

##### format格式库

头文件：`format`

`format(...)`返回类型的值和字符串形式，**使用格式与python的format相同。**

使用print代替cout

```c++
#include <format>
#include <string_view>
#include <cstdio>
template<typename... Args>
void print(const string_view fmt_str, Args&&... args) {
	auto fmt_args{ make_format_args(args...) };
	string outstr{ vformat(fmt_str, fmt_args) };
	fputs(outstr.c_str(), stdout);
}
```

若是直接输出一个类类型的对象时会报错，**需要进行格式特化**

```c++
struct Frac {
 long n;
 long d;
};
int main() {
 Frac f{ 5, 3 };
 print("Frac: {}\n", f);
}
template<> struct std::formatter<Frac> // 修改Frac
{
 template<typename ParseContext>
 	constexpr auto parse(ParseContext& ctx) {
 		return ctx.begin(); // 不动
	}
template<typename FormatContext> auto format(const Frac& f, FormatContext& ctx) { // 只需要替换Frac为自己的特化类
	 return format_to(ctx.out(), "{0:d}/{1:d}", // 自己定义格式，数字代表索引
 f.n, f.d); //对象属性
	}
};
```

##### constexpr

constexpr函数更加的宽松，可以在其中使用字符串和`vector`，但是函数中的对象必须析构，运行时无法使用。使用vector对象的返回值时，函数中的局部变量也要声明为`constexpr`

##### 安全的比较

在`utility`中定义了一些比较函数，**方便了无符号和有符号数之间的正常比较**

* `cmp_equal`
* `cmp_not_equal`
* `cmp_less`
* `cmp_less_equal`
* `cmp_greater`
* `cmp_greater_equal`

###### 三向比较

`compare`头文件

`<=>`运算符，`a<=>b`

* 返回值`=0`两侧相等
* 返回值`>0`左大于右
* 返回值`<0`左小于右

##### version头文件

所有库特性的测试宏，都会放到该头文件中。所有特性测试宏都以`__cpp_`开头，库特性以`__cpp_lib`开头

##### 概念和约束

可以约束模板的类型

`concepts`头文件中

```c++
template <typename T>
requires Numeric<T> // 需要提供数字类型 
// 这里的Numeric可以自己定义如：template <class T> concept Numeric = is_gt_byte<T> &&(integral<T>||floating_point<T>)。这里可以使用逻辑符，如：!is_gt_byte<T>
// requires除了使用概念，还可以进行判断bool，如template<int N>requires (N>10)
...
```

约束一般使用`type_traits`头文件中`is_...`模板类来限定或者`concepts`头文件中包含的概念

定义一个概念 -- 约束类型：**为了当作约束使用，返回类型必须是：`constexpr bool`**

```c++
template <typename T>
constexpr bool is_xxx{sizeof(T)>1;} 该类型是一个概念，表示满足类型的字节数>1时才满足约束
// 上述是定义一个约束
template <class T> concept Numeric = is_gt_byte<T> &&(integral<T>||floating_point<T>)
// 定义一个概念，使用concept关键字
```

##### span

接收一个C数组，可以替代数组指针，**最大的好处是可以获取数组中的元素数量**，如：

```c
int a[2];
span <int> c = a;
```

 
