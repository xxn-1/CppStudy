#### PIMPL模式

其基本思想是将一个外部可见类(visible class)的实现细节（一般是所有私有的非虚成员）放在一个单独的实现类(implementation class)中，而在可见类中通过一个私有指针来间接访问该实现类。

```c++
class actual {
public:
    actual():Impl(make_shared<Impl>()){}
    ~actual();
    actual(actual&& rhs);
    actual& operator=(actual&& rhs);
    actual(const actual& rhs);
	actual& operator=(const actual& rhs);
    void swap(const actual &other);
private:
    struct Impl;
    shared_ptr<Impl>impl; // 只包含一个指针
}
struct actual::Impl {
    // 实际的实现
}
actual::~actual() = default;
actual::actual(actual&& rhs) = default;
actual& actual::operator=(actual&& rhs) = default;
actual::actual(const actual& rhs)
    : pimpl_{std::make_unique<Impl>(*rhs.pimpl_)} {}
actual& actual::operator=(const actual& rhs) {
  *pimpl_ = *rhs.pimpl_;
  return *this;
};
```

定义`actual`类时，我们需要显式或隐式地定义5个特殊成员函数:拷贝构造函数、拷贝赋值操作符、移动构造函数、移动赋值操作符和析构函数来确定复制、移动、赋值和销毁`actual`类的对象时会发生什么。如果我们使用`std::unique_ptr`来实现Pimpl，这个5个特殊函数都需要在源文件中定义，而不是由编译器在头文件中自动合成





##### 结合copy and swap

在`actual`类间的`swap`可以只需要交换指针。



#### NVI模式

令用户通过`public non-virtual`成员函数间接调用`private virtual`成员函数。

NVI手法中的非虚函数作为一种**代理的外覆器**，可以完成进行前的准备和进行后的收尾工作。



#### Strategy模式

为**管理类**定义一个私有成员变量指针指向一个接口基类，接口一般为纯虚类，在其一些成员函数中可以藉由该指针指向的类完成真正的工作，**注意，一般管理类和其真正的实现类都有相同的成员函数，该模式类似于PIMPL，差别在于成员指针指向的是一个抽象基类，其拥有多种实现。**。

```c++

class IWind{
public:
	virtual ~IWind(){};
	virtual void blowWind() = 0;
};
 
class ColdWind : public IWind{
public:
	void blowWind(){
		cout<<"Blowing cold wind!"<<endl;
	};
};
 
class WarmWind : public IWind{
public:
	void blowWind(){
		cout<<"Blowing warm wind!"<<endl;
	}
};
 
class NoWind : public IWind{
public:
	void blowWind(){
		cout<<"No Wind!"<<endl;
	}
};
```



#### 插件模式

通常是`private`继承，将功能抽象为一个模板订制

```c++
#include <iostream>
using namespace std;
template <class BeingCounted>
class Counted
{
public:
    class TooManyObjects
    {
    };
    static int objectCount() { return numObjects; }

protected:
    Counted();
    Counted(const Counted &rhs);
    ~Counted() { --numObjects; }

private:
    static int numObjects;
    static const size_t maxObjects = 10; // 必须初始化由用户完成
    void init();
};
template <class BeingCounted>
Counted<BeingCounted>::Counted()
{
    init();
}
template <class BeingCounted>
Counted<BeingCounted>::Counted(const Counted<BeingCounted> &)
{
    init();
}
template <class BeingCounted>
void Counted<BeingCounted>::init()
{
    if (numObjects >= maxObjects)
    {
        throw TooManyObjects();
    }
    ++numObjects;
    cout << numObjects << endl;
}
template <class BeingCounted> // 定义numObjects
int Counted<BeingCounted>::numObjects = 0;
class PrintJob
{
};
class Printer;
class Printer : private Counted<Printer>
{
public:
    static Printer *makePrinter();
    static Printer *makePrinter(const Printer &rhs);
    //     ~Printer();
    //     void submitJob(const PrintJob &job);
    //     void reset();
    //     void performSelfTest();
    //     using Counted<Printer>::objectCount; // 开放接口
    //     using Counted<Printer>::TooManyObjects;

private:
    Printer() = default;
    Printer(const Printer &rhs) = default;
};
Printer *Printer::makePrinter()
{
    return new Printer;
}
Printer *Printer::makePrinter(const Printer &rhs)
{
    return new Printer(rhs);
}
int main()
{
    Printer *printer1 = Printer::makePrinter();
    Printer *printer2 = Printer::makePrinter();
    Printer *printer3 = Printer::makePrinter();
    Printer *printer4 = Printer::makePrinter();
    Printer *printer5 = Printer::makePrinter();
    Printer *printer6 = Printer::makePrinter();
    Printer *printer7 = Printer::makePrinter();
    Printer *printer8 = Printer::makePrinter();
    Printer *printer9 = Printer::makePrinter();
    Printer *printer10 = Printer::makePrinter();
    Printer *printer11 = Printer::makePrinter();
    // Printer *printer1 = new Printer();
}
```

