**记录一些遗漏的C++知识点**

[TOC]

---
#### 基础遗漏
1. `e`指数表示：`1.3e3`表示1300
2. 末尾可以用`\`换行
3. 字面值常量的前缀和后缀添加，改变默认类型，在不同类型上应用会有不同效果。  
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符、字符串(前缀):
    * `u`char16_t
    * `U`char32_t
    * `L`wchar_t
    * `u8`char(UTF-8)  
    整形:
    * `u/U`unsigned
    * `l/L`long
    * `ul/UL`unsigned long
    * `ll/LL`long long  
    浮点数:
    * `f/F`float
    * `l/L`long double
4. 变量声明和定义的区别。一个变量能且仅能够被定义一次，但是可以被多次声明(extern)，声明时不需要初始化，若是声明时初始化则不是声明而是定义，如`extern int i = 3`已经变化为定义。
5. `::变量名`显式的访问全局变量中的变量，若是有局部变量名与全局变量名相同时，可以如此访问。`::i/i`（全局作用域没有名字）
6. 引用的类型必须与所引用的对象的类型一致。除了：
    * `const int &r = 10;`正确，直接用常量值绑定
    * `int i = 1;int &r1 = i;const int &r2 = i;`此时可以通过r1或直接修改i的值，但是不能通过r2修改值。
7. 指针和const
    * `const int *p = &i;`此时p指向的地址可以修改，但是不能改变其所指地址对象的值，并不要求所指对象是常量值，仅仅是表示不能通过该指针修改其值。
    * `int *const p = &i;`表示指针本身是常量，其所指的地址不能改变。
    * `const int *const p =&i;`**一般把前const称作底层const,后const称作顶层const，拷贝赋值时必须有相同的底层const。当然普通类型可以转化为const类型，反之不行。**
8. 常量表达式关键字`constexpr`，常量表达式由**数据类型**和**初始值**共同决定。  
    * `constexpr int t = 20;`常量表达式
    * `constexpr int sz = size()`**只有size()函数是一个constexpr函数时才是正确的声明语句，新标准允许定义一种特殊的constexpr函数(返回值必须是字面值常量，传递进去的实参必须是字面值常量，函数体中必须有且仅有一条return语句)<font color='red'> |算术类型、引用、某个固定地址的指针都属于字面值常量| </font>使得编译时就获得结果**
    > 注意，`constexpr`修饰指针时与const不同，`constexpr int *p = nullptr`表示p该指针指向不能改变。
9. 基于范围的for语句  
```c++
// string a - 处理每个字符
for(auto c:a) {
    cout << c;
}
// 若要改变字符，需要使用引用
for(auto &c:a) {
    c = c + '1';
}
// 若要处理多维数，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型
for(auto &row:a) {
    for(auto &x:row){
        ...
    }
}
```
10. 数组的指针
    * `int *ptr[10];`含有10个整型指针的数组
    * `int (*ptr)[10]`指针指向一个含有10个整数的数组
    * `int &ptr[10];`不存在引用的数组
    * `int (&ptr)[10];`引用一个含有10个整数的数组  
    > 头文件`<iterator>`定义了函数`begin()/end()`方便我们获得数组的头指针和尾元素下一个位置的指针。
11. char数组的比较：不能直接使用运算符比较，此时比较的是指针而非值本身。要使用`strcmp`
12. 可变形参
    * `initializer_list<T>`所有实参类型需要相同，其中对象永远为常量值，不可以修改其对象中的值。
13. 内联函数和constexpr函数
14. `assert(表达式)`如果表达式为0输出信息并终止程序执行，表达式为1，什么都不做。依赖于`NDEBUG`预处理变量，如果定义了`#define NDEBUG`则`assert`什么都不做。
15. 预处理器的四个内置变量
    * `__FILE__`:存放文件名的字符串字面值
    * `__LINE__`:存放当前行号的整形字面值
    * `__TIME__`:存放文件编译时间的字符串字面值
    * `__DATE__`:存放文件编译日期的字符串字面值
    * `__func__`:存放当前函数名的字符串字面值
16. `namespace name{代码块}`
---
#### 类型处理
##### 别名
&nbsp;&nbsp;推荐使用`using`代替`typedef`，`using`比起`typedef`来易读，并且支持模板别名。</br>

* `using func = void(*)(int);`
* `template<typename T> using map_ss = unordered_map<std::string, T>;`<br/>
`map_ss<int> unmap;// ==> unordered_map<std::string, int> unmap;`

##### 类型推导
* `auto`关键字，推导时会去掉顶层const，需要手动加`const auto i = 1;`
* `decltype(变量/值...)`，获取某个值的类型，`decltype(sum()) x = sum()`;`decltype`中的值如果加了括号，如`decltype((i))`(->一定为引用的类型)和`decltype(i)`不同。
```C++
//推导函数
int a(int b){};
decltype(a)* p = a// 指向函数a的指针。
```
* 

---
#### 特性
* `[[noreturn]]` 指定函数永不返回
* `[[carries_dependency]]`指定函数传播线程同步的数据依赖项顺序。 可将该属性应用于一个或多个参数，以指定传入的参数要将依赖项带入函数主体中。 可将该属性应用于函数本身，以指定返回值要将依赖项带出函数。 编译器可以使用此信息来生成更有效的代码。
* `[[deprecated]]`特性 [[deprecated]] 可以应用于类、typedef-name、变量、非静态数据成员、函数、命名空间、枚举、枚举器或模板专用化的声明。 当客户端代码尝试调用该函数时，编译器可以使用此属性来生成信息性消息。 当Microsoft C++ 编译器检测到项的使用[[deprecated]]时，会引发编译器警告 C4996。
* `[[fallthrough]]`指定函数的返回值不应被丢弃。
* `[[nodiscard]]`
* `[[maybe_unused]]`
* `[[likely]]`
* ``[[unlikely]]``
---
#### 命名空间
* `using namespace 命名空间名`使用该命名空间所有名字
* `using 命名空间名::具体名字`，如:`using std::cin`
---
#### 运算符
* `typeid`定义在<typeinfo>头文件中，允许在运行时获得变量的类型名。例子：`int a;cout << typeid(a).name();`可以在模板中使用，确定类型。`typeid(T).name()`
* `alignof(类型名)`返回类型的字节数。`class Car{};cout << alignof(Car);`
* `alignas(类型名)`修改单独变量或者类的对齐大小，在定义时添加使用
* `sizeof...(name)`参数包的大小
* `throw expr`抛出异常
* `noexcept(expr)`不带参数等价于true，当 noexcept 是 true 时表示函数不会抛出异常，
当 noexcept 是 false 时表示函数可能会抛出异常，可以定义在函数中，也可以单独使用`noexcept(函数名(实参))`检查函数声明的是true还是false。`void g() noexcept {};`带参用来检测某个行为是否会引发异常`template <class T> void swap(T &a, T &b) noexcept(noexcept (T(std::move(a))) && noexcept (a.operator=(std::move(b)))) `
```C++
struct stTestAlign
{
    char a;
    alignas(4) char b;
    stTestAlign()
    {
        cout << "sizeof(stTestAlign) =" << sizeof(stTestAlign) << endl;   //8
        cout << "alignof(stTestAlign) =" << alignof(stTestAlign) << endl; //4
    }
};
// 同时修改类的对齐依据，跟变量的(4)两者对齐依据取其大
struct alignas(2) stTestAlign
{
    char a;
    alignas(4) char b;
    stTestAlign()
    {
        cout << "sizeof(stTestAlign) =" << sizeof(stTestAlign) << endl;   //8
        cout << "alignof(stTestAlign) =" << alignof(stTestAlign) << endl; //4
    }
};

```
---
#### 类
* 常量成员函数` int GetYear() const { return y; }`。在函数中只能访问本类的其他常量成员函数，同时不能修改成员变量（除了标记为mutable的成员变量）
* 友元函数，在类外定义的函数在类内使用`friend`关键字再次声明后，该函数可以修改类的私有成员。也可以指定友元类，友元类的对象可以操作该类的私有成员。也可以仅令其他类的某个成员函数为友元函数:`friend type 类名::name(...);`
* 如果成员是const、引用，或者属于类类型，必须通过构造函数初始值列表为成员提供初值，不能放在打括号内初始化。`:i(放在这里){不能放在这里;}`
* <font color="red">委托构造函数</font>，把构造函数初始化值的过程交给其它构造函数来完成。
```C++

class Person
{
public:
    Person() :Person(1, 'a') {}
    Person(int i) : Person(i, 'a') {}
    Person(char ch) : Person(1, ch) {} 
 
private:
    Person(int i, char ch) :type(i), name(ch) {/*其他初始化信息*/}
    int type{ 1 };
    char name{ 'a' };
};
```
* 字面值常量类：字面值类型的要求
    - 数据成员都必须是字面值类型
    - 类必须至少含有一个`constexpr`构造函数,`constexpr`构造函数必须初始化所有数据成员
    - 如果数据成员含有类内初始值，则该初始值必须是一条常量表达式，若成员为类类型，则初始值必须使用该类型的`constexpr`构造函数
    - 类必须使用析构函数的默认定义
* 类的静态成员函数使用：`类名::静态成员函数(...)`。类的静态成员定义在类外（除了静态**常量成员**可以定义在类内）：`type 类::成员变量名 = 初始化值`，即使静态成员在类内定义初始化后，也要在类的外部定义一下该成员。
> 静态成员和普通成员的区别，静态类成员类型可以就是他所属的类的类型，而普通成员必须是该类类型的指针或引用。
---
#### 迭代器
迭代器要针对具体的容器类型<br/>

* `vector<int>::iterator it;string::iterator it;`支持读写的迭代器
* `vector<int>::const_iterator it;`仅支持读的常量指针
```c++
// begin() or end()
获取iterator类型
// cbegin() or cend()
获取const_iterator类型
// rbegin() or rend()
获取reverse_iterator类型 - 反向迭代器
// crbegin() or crend()
```
##### 类型
1. 插入迭代器，以下都是函数：
    * `back_inserter`借助push_back
    * `front_inserter`借助push_front
    * `inserter`借助insert，需要传入第二个参数，是一个迭代器
2. 流迭代器：绑定到输出或输入流，遍历IO流，使用时，需要创建两个迭代器，一个用于指定读入的流对象，另一个作为尾后迭代器
    * `istream_iterator<type>it(流对象)`
    * `istream_iterator<type>eof`作为尾后迭代器
    ```c++
    // 可以直接将流放到容器中
    istream_iterator< int > initer(cin),eof;
    vector< int > nums(initer,eof);
    // 或单独读出流中一个元素
    cout << *initer++;
    // 运用到泛型算法中
    accumulate(initer,eof,0);
    ```
    * `ostream_iterator<type> out_iter(cout," ")`其中接收一个输出流，第二个参数会在每次输出后默认输出一个" "。
     ```c++
    // 可以直接将流输出
    ostream_iterator< int > out_iter(cout);
    vector< int > nums;
    copy(nums.begin(),nums.end(),out_iter);
    // 或单独读出流中一个元素
    *out_iter = nums[0];
     
     ```
3. 反向迭代器
4. 移动迭代器：不拷贝元素，而是移动他们。
---
#### 异常
异常定义的几个头文件`exception`、`stdexcept`、`new`（包含bad_alloc异常）、`typeinfo`（包含bad_cast异常）
```c++
// stdexcept定义的几个异常
exception 最常见的问题
runtime_error 只有在运行时才能检测到的问题
range_error 运行时错误：超出有意义的范围
overflow_error 计算上溢出
underflow_error 下溢出
logic_error 程序逻辑错误
domain_error  参数对应的结果值不存在
invalid_argument 无效参数
length_error 超出该类型最大长度的对象
out_of_range 使用一个超出有效范围的值
```

* `throw 异常类型(信息);`
* `try`语句
```c++
try{

}catch(异常类型 e){

}catch(异常类型 e){

}
```
---
#### 类型转换
* `static_cast`常用于明确定义的强制类型转换
* `dynamic_cast`将基类指针转化到派生类指针。
* `const_cast`改变底层const的转换
* `reinterpret_cast`
---
#### IO库
包含三个重要的头文件：  
1. `iostream`:用于读写流，包含  
    `istream/wistream`:读取|`ostream/wostream`:写入|`iostream/wiostream`:读写  
2. `fstream`:用于读写命名文件:  
    `ifstream/wifstream`:读取|`ofstream/wofstream`:写入|`fstream/wfstream`:读写  
3. `sstream`:用于读写内存对象string对象  
    `istringstream/wistringstream`:读取|`ostringstream/wostringstream`写入|`stringstream/wstringstream`读写<br/>
    流的状态有4种：`badbit(s.bad(),指出流已崩溃)/failbit(s.fail(),表示IO操作失败了)/eofbit(s.eof(),表示流到文件结束)/goodbit`。可使用位运算设置多种状态一次性。  
    其它的一些函数：`s.clear()/s.clear(status)清除指定的状态`  、`s.rdstate()`返回当前的状态。`s.setstate(status)`<br>
    刷新输出缓冲区的方法：<br>
1. `endl`输出换行并刷新  
2. `ends`输出一个空白字符，然后刷新缓冲区  
3. `flush`不附加字符的刷新  
4. `cout << unitbuf/cout << nounitbuf`设置任何输出后都立即刷新缓冲区  
##### 输入输出流之间的关联
> 当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。

通过`s.tie()`返回与当前输入流相关联的输出流。通过`s.tie(输出流的地址)`将输出流关联到此输出流，输出流地址为`nullptr`时表示输入流不再与其他流关联。
##### 文件打开的几种模式
这些模式放在命名域`ios_base::`下：  
1. in  
2. out  
3. binary  
4. ate打开的时候定位到文件末尾  
5. app每次写操作前都定位到文件末尾  
6. trunc丢弃打开前文件的内容  
几个限制：
```c++
1. 只能对ofstream只能设置out，ifstream只能设置in
2. 只有设定为out后才能设置trunc
3. 没有设定trunc才能设定app
4. 默认情况以out打开文件会丢弃文件内容，需要指定app模式。
```
##### sstream
一些函数：  
1. `strm.str()`返回sstream保存的string，`strm.str(s)`将string s拷贝进sstream中。  

---
#### 容器
##### 顺序容器
`vector、deque、list、forword_list、array、string`  
顺序容器的几种类型别名：
1. iterator  
2. const_iterator  
3. size_type  
4. difference_type  
5. value_type  
6. reference  
7. const_reference  
> 容器初始化拷贝时，不通过迭代器的初始化都要求容器的类型相同。  
容器array的使用，除了定义类型，还要定义大小：`array<int,32>a;`

顺序容器适配器：`queue、priority_queue、stack`
```C++
// 适配器默认情况下queue和stack是基于deque实现的，而priority_queue是基于vector实现的
如：stack<int>s;
// 支持重载容器类型，通过设置第二个参数
stack<int,vector<int>>s;
// stack支持除array和forword_list之外的所有容器
// queue支持构造在list和deque上
// priority_queue支持构造在vector和deque上
```
##### 关联容器
* `map`:包含`.first、.second`两个成员，关键字不能修改，值允许。
* `set`值不能修改
* `multimap`
* `multiset`
* `unordered_map`
* `unordered_set`
* `unordered_multimap`
* `unordered_multiset`
>注意：这些有序容器的元素类型必须支持比较操作'<'，如list列表并不支持所以不能作为元素。
这些容器可以重载比较运算符，我们需要传递一个重载的函数指针，以及具体的函数，如：
```C++
bool compareIs(const int &a, const int &b)
{
    return a > b;
}
vector< int > vs = {421, 12, 4321, 23, 5241, 211, 53532, 121};
set< int, decltype(compareIs) * > nums(vs.begin(), vs.end(), compareIs);
```
**这些关联容器的`insert`操作会返回一个`pair`类型，`first`是一个`map`迭代器位置，`second`是一个`bool`表示是否插入成功**
* `lower_bound`返回指向第一个具有给定关键字的元素
* `upper_bound`返回最后一个匹配给定的关键字的元素之后的位置
* `equal_range`返回一个pair，包含相等元素的首和尾迭代器
###### 无序容器

无需容器的桶策略

![][642e59e5a682492fcca021bee.png]  
不同关键字哈希后可能分配到相同的桶后，再顺序比较

**无序容器若想定义其类型为自定义类型，需要重载`==`运算符和哈希值计算函数**：

```C++
size_t hasher(const Student& stu) {
    return hash<string>()(stu.id); // 库函数
}
bool eq(const Student& stu1,const Student& stu2) {
    return stu1.id == stu2.id;
}
unordered_multiset<Student,decltype(hasher)*,decltype(eq)*>s(42,hasher,eq);
```



##### pair类型
* `pair<type1,type2>p;`
* 构造：`make_pair(v1,v2)`返回一个pair。
---
#### 泛型算法
大多数定义在头文件`<algorithm>`中，`numeric`定义了一些数值算法。[algorithm算法库][algorithm]。这些算法是支持不同容器中不同类型的比较的，前提是这些类型的比较是允许的。  
    泛型算法的特点:算法总是通过<font color="red">迭代器</font>操作容器，因此不能直接向/从容器添加、删除元素，无法改变容器大小。**泛型算法对于容器的要求并不是有足够的空间，而是有足够的元素。即.size()的大小要足够，因此对一个空容器调用reserve(n)也是不可以的；只能通过插入迭代器函数来完成改变元素个数的操作**
> sort算法是利用元素类型的“<”来实现排序的
##### 插入迭代器(back_inserter)函数
接受一个指向容器的引用，返回一个插入迭代器。向返回的插入迭代器赋值时，会调用`push_back`将该值插入到容器中。例子：
```C++
vector<int>vec;
fill_n(back_inserter(vec),10,0);//借助插入迭代器向和泛型算法fill_n向容器中插入10个0。
```
---
##### 谓词
某些泛型算法还有重载后的版本，接受第三个参数，此参数是一个**谓词**。本质是一个可调用的表达式，返回结果是一个能用作条件的值。谓词的类型共有两种：一元谓词、二元谓词。
>注意：谓词在泛型算法中只用写出谓词函数的名字，不用写实参。
---
##### lambda表达式
通常形式为:`[捕获列表](参数列表)mutable throw(类型)->返回类型{函数体};`  
捕获列表讲解：lambda通常只能访问使用外部的全局变量，而不能使用函数里的局部变量，因此需要捕获列表。[x,y,z]如上，三个局部变量补获后已经可以在lambda中使用了。捕获的方式分为：<br>
* 按值捕获:若按值捕获时想要修改变量的值，需要添加上`mutable`关键字。  
* 引用捕获`[&x,&y]`  
* 隐式捕获，包含：  
&nbsp;&nbsp;1. `[=]`:函数局部作用域里的所有变量都按值捕获  
&nbsp;&nbsp;2. `[&]`:函数局部作用域里的所有变量都按引用捕获  
&nbsp;&nbsp;3. `[=, reference_list:]`:reference list里的变量按引用捕获，其余的变量按值捕获，比如 [=, &a, &b] 表示 a 和 b 按引用，其余按值捕获   
&nbsp;&nbsp;4. `[&, identifier_list]`identifier list里的变量按值捕获，其余的变量按引用捕获，比如 [&, a, b] 表示 a 和 b 按值，其余按引用捕获  

使用：
```C++
auto f = []()->{return 3;}
cout << f() << endl;
```
---
##### bind函数
定义在`<functional>`头文件中  
可以将参数绑定在某个函数上，返回新的函数句柄。假如我们已经拥有函数test，`bind`函数有些特殊参数:`_1`、`_2`等等，若是使用这些参数，则会将调用函数f传来的形参传递给test调用，而bind还支持自己定义默认的参数绑定到test上。。`auto f = bind(test,_1,...)`
> 注意：这些占位符都放在`placeholders`命名空间中

但是若希望在bind函数中传递某些无法拷贝的值，就需要传递引用，因此可以借助`ref`或`cref`函数。如`ostream s;bind(test,ref(s))`

#### 智能指针

都定义在`<memory>`头文件中，以下智能指针都是模板，需要提供**类型**。

* `shared_ptr<type>`计数器为0时自动释放

  ```c++
  shared_ptr<string>p
  if(p && p->empty) // 如果p指针不为空，且指向一个空string。
  shared_ptr<T> ptr(new T()); // ptr引用计数为0时，dui'xiang'zi
  ```

  * `p.get()`获得智能指针中保存的指针。
  * `make_shared<type>(参数)`使用指针初始化返回一个shared_ptr，这里参数并不限，比如说可以是`make_shared<int>(32)`指向一个int为32的指针。
  * `p.unique()`判断其引用是否为1
  * `p.use_count()`返回其共享对象的智能指针数量

* `unique_ptr<type>`

* `weak_ptr<type>`

#### __attribute__属性

#### C++11新特性
#### C++14新特性

#### C++17新特性

[algorithm]: https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm?source=recommendations&view=msvc-170
[642e59e5a682492fcca021be.png]: https://pic.imgdb.cn/item/642e59e5a682492fcca021be.png
[642e59e5a682492fcca021bee.png]:https://pic.imgdb.cn/item/642e59e5a682492fcca021be.png
