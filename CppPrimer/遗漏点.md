**记录一些遗漏的C++知识点**

[TOC]

---
#### 基础遗漏
1. `e`指数表示：`1.3e3`表示1300
2. 末尾可以用`\`换行
3. 字面值常量的前缀和后缀添加，改变默认类型，在不同类型上应用会有不同效果。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符、字符串(前缀):
    * `u`char16_t
    * `U`char32_t
    * `L`wchar_t
    * `u8`char(UTF-8)  
    整形:
    * `u/U`unsigned
    * `l/L`long
    * `ul/UL`unsigned long
    * `ll/LL`long long  
    浮点数:
    * `f/F`float
    * `l/L`long double
4. 变量声明和定义的区别。一个变量能且仅能够被定义一次，但是可以被多次声明(extern)，声明时不需要初始化，若是声明时初始化则不是声明而是定义，如`extern int i = 3`已经变化为定义。
5. `::变量名`显式的访问全局变量中的变量，若是有局部变量名与全局变量名相同时，可以如此访问。`::i/i`（全局作用域没有名字）
6. 引用的类型必须与所引用的对象的类型一致。除了：
    * `const int &r = 10;`正确，直接用常量值绑定
    * `int i = 1;int &r1 = i;const int &r2 = i;`此时可以通过r1或直接修改i的值，但是不能通过r2修改值。
7. 指针和const
    * `const int *p = &i;`此时p指向的地址可以修改，但是不能改变其所指地址对象的值，并不要求所指对象是常量值，仅仅是表示不能通过该指针修改其值。
    * `int *const p = &i;`表示指针本身是常量，其所指的地址不能改变。
    * `const int *const p =&i;`**一般把前const称作底层const,后const称作顶层const，拷贝赋值时必须有相同的底层const。当然普通类型可以转化为const类型，反之不行。**
8. 常量表达式关键字`constexpr`，常量表达式由**数据类型**和**初始值**共同决定。  
    * `constexpr int t = 20;`常量表达式
    * `constexpr int sz = size()`**只有size()函数是一个constexpr函数时才是正确的声明语句，新标准允许定义一种特殊的constexpr函数(返回值必须是字面值常量，传递进去的实参必须是字面值常量，函数体中必须有且仅有一条return语句)<font color='red'> |算术类型、引用、某个固定地址的指针都属于字面值常量| </font>使得编译时就获得结果**
    > 注意，`constexpr`修饰指针时与const不同，`constexpr int *p = nullptr`表示p该指针指向不能改变。
9. 基于范围的for语句  
```c++
// string a - 处理每个字符
for(auto c:a) {
    cout << c;
}
// 若要改变字符，需要使用引用
for(auto &c:a) {
    c = c + '1';
}
```
---
#### 类型处理
##### 别名
&nbsp;&nbsp;推荐使用`using`代替`typedef`，`using`比起`typedef`来易读，并且支持模板别名。</br>

* `using func = void(*)(int);`
* `template<typename T> using map_ss = unordered_map<std::string, T>;`<br/>
`map_ss<int> unmap;// ==> unordered_map<std::string, int> unmap;`

##### 类型推导
* `auto`关键字，推导时会去掉顶层const，需要手动加`const auto i = 1;`
* `decltype(变量/值...)`，获取某个值的类型，`decltype(sum()) x = sum()`;`decltype`中的值如果加了括号，如`decltype((i))`(->一定为引用的类型)和`decltype(i)`不同。
* 

---
#### 特性
* `[[noreturn]]` 指定函数永不返回
* `[[carries_dependency]]`指定函数传播线程同步的数据依赖项顺序。 可将该属性应用于一个或多个参数，以指定传入的参数要将依赖项带入函数主体中。 可将该属性应用于函数本身，以指定返回值要将依赖项带出函数。 编译器可以使用此信息来生成更有效的代码。
* `[[deprecated]]`特性 [[deprecated]] 可以应用于类、typedef-name、变量、非静态数据成员、函数、命名空间、枚举、枚举器或模板专用化的声明。 当客户端代码尝试调用该函数时，编译器可以使用此属性来生成信息性消息。 当Microsoft C++ 编译器检测到项的使用[[deprecated]]时，会引发编译器警告 C4996。
* `[[fallthrough]]`指定函数的返回值不应被丢弃。
* `[[nodiscard]]`
* `[[maybe_unused]]`
* `[[likely]]`
* ``[[unlikely]]``
#### 命名空间
* `using namespace 命名空间名`使用该命名空间所有名字
* `using 命名空间名::具体名字`，如:`using std::cin`


#### C++14新特性

#### C++17新特性
