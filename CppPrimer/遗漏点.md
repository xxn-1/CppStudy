

**记录一些遗漏的C++知识点**

[TOC]

---
#### 基础遗漏
1. `e`指数表示：`1.3e3`表示1300
2. 末尾可以用`\`换行
3. 字面值常量的前缀和后缀添加，改变默认类型，在不同类型上应用会有不同效果。  
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符、字符串(前缀):
    * `u`char16_t
    * `U`char32_t
    * `L`wchar_t
    * `u8`char(UTF-8)  
    整形:
    * `u/U`unsigned
    * `l/L`long
    * `ul/UL`unsigned long
    * `ll/LL`long long  
    浮点数:
    * `f/F`float
    * `l/L`long double
4. 变量声明和定义的区别。一个变量能且仅能够被定义一次，但是可以被多次声明(extern)，声明时不需要初始化，若是声明时初始化则不是声明而是定义，如`extern int i = 3`已经变化为定义。
5. `::变量名`显式的访问全局变量中的变量，若是有局部变量名与全局变量名相同时，可以如此访问。`::i/i`（全局作用域没有名字）
6. 引用的类型必须与所引用的对象的类型一致。除了：
    * `const int &r = 10;`正确，直接用常量值绑定
    * `int i = 1;int &r1 = i;const int &r2 = i;`此时可以通过r1或直接修改i的值，但是不能通过r2修改值。
7. 指针和const
    * `const int *p = &i;`此时p指向的地址可以修改，但是不能改变其所指地址对象的值，并不要求所指对象是常量值，仅仅是表示不能通过该指针修改其值。
    * `int *const p = &i;`表示指针本身是常量，其所指的地址不能改变。
    * `const int *const p =&i;`**一般把前const称作底层const,后const称作顶层const，拷贝赋值时必须有相同的底层const。当然普通类型可以转化为const类型，反之不行。**
8. 常量表达式关键字`constexpr`，常量表达式由**数据类型**和**初始值**共同决定。  
    * `constexpr int t = 20;`常量表达式
    * `constexpr int sz = size()`**只有size()函数是一个constexpr函数时才是正确的声明语句，新标准允许定义一种特殊的constexpr函数(返回值必须是字面值常量，传递进去的实参必须是字面值常量，函数体中必须有且仅有一条return语句)<font color='red'> |算术类型、引用、某个固定地址的指针都属于字面值常量| </font>使得编译时就获得结果**
    > 注意，`constexpr`修饰指针时与const不同，`constexpr int *p = nullptr`表示p该指针指向不能改变。
9. 基于范围的for语句  
```c++
// string a - 处理每个字符
for(auto c:a) {
    cout << c;
}
// 若要改变字符，需要使用引用
for(auto &c:a) {
    c = c + '1';
}
// 若要处理多维数，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型
for(auto &row:a) {
    for(auto &x:row){
        ...
    }
}
```
10. 数组的指针
    * `int *ptr[10];`含有10个整型指针的数组
    * `int (*ptr)[10]`指针指向一个含有10个整数的数组
    * `int &ptr[10];`不存在引用的数组
    * `int (&ptr)[10];`引用一个含有10个整数的数组  
    > 头文件`<iterator>`定义了函数`begin()/end()`方便我们获得数组的头指针和尾元素下一个位置的指针。
11. char数组的比较：不能直接使用运算符比较，此时比较的是指针而非值本身。要使用`strcmp`
12. 可变形参
    * `initializer_list<T>`所有实参类型需要相同，其中对象永远为常量值，不可以修改其对象中的值。
13. 内联函数和constexpr函数
14. `assert(表达式)`如果表达式为0输出信息并终止程序执行，表达式为1，什么都不做。依赖于`NDEBUG`预处理变量，如果定义了`#define NDEBUG`则`assert`什么都不做。
15. 预处理器的四个内置变量
    * `__FILE__`:存放文件名的字符串字面值
    * `__LINE__`:存放当前行号的整形字面值
    * `__TIME__`:存放文件编译时间的字符串字面值
    * `__DATE__`:存放文件编译日期的字符串字面值
    * `__func__`:存放当前函数名的字符串字面值
16. `namespace name{代码块}`
17. 
---
#### 类型处理
##### 别名
&nbsp;&nbsp;推荐使用`using`代替`typedef`，`using`比起`typedef`来易读，并且支持模板别名。</br>

* `using func = void(*)(int);`
* `template<typename T> using map_ss = unordered_map<std::string, T>;`<br/>
`map_ss<int> unmap;// ==> unordered_map<std::string, int> unmap;`

##### 类型推导
* `auto`关键字，推导时会去掉顶层const，需要手动加`const auto i = 1;`
* `decltype(变量/值...)`，获取某个值的类型，`decltype(sum()) x = sum()`;`decltype`中的值如果加了括号，如`decltype((i))`(->一定为引用的类型)和`decltype(i)`不同。
```C++
//推导函数
int a(int b){};
decltype(a)* p = a// 指向函数a的指针。
```
* 

---
#### 特性
* `[[noreturn]]` 指定函数永不返回
* `[[carries_dependency]]`指定函数传播线程同步的数据依赖项顺序。 可将该属性应用于一个或多个参数，以指定传入的参数要将依赖项带入函数主体中。 可将该属性应用于函数本身，以指定返回值要将依赖项带出函数。 编译器可以使用此信息来生成更有效的代码。
* `[[deprecated]]`特性 [[deprecated]] 可以应用于类、typedef-name、变量、非静态数据成员、函数、命名空间、枚举、枚举器或模板专用化的声明。 当客户端代码尝试调用该函数时，编译器可以使用此属性来生成信息性消息。 当Microsoft C++ 编译器检测到项的使用[[deprecated]]时，会引发编译器警告 C4996。
* `[[fallthrough]]`指定函数的返回值不应被丢弃。
* `[[nodiscard]]`
* `[[maybe_unused]]`
* `[[likely]]`
* ``[[unlikely]]``
---
#### 命名空间
* `using namespace 命名空间名`使用该命名空间所有名字
* `using 命名空间名::具体名字`，如:`using std::cin`
---
#### 运算符
* `typeid`定义在<typeinfo>头文件中，允许在运行时获得变量的类型名。例子：`int a;cout << typeid(a).name();`可以在模板中使用，确定类型。`typeid(T).name()`
* `alignof(类型名)`返回类型的字节数。`class Car{};cout << alignof(Car);`
* `alignas(类型名)`修改单独变量或者类的对齐大小，在定义时添加使用
* `sizeof...(name)`参数包的大小
* `throw expr`抛出异常
* `noexcept(expr)`不带参数等价于true，当 noexcept 是 true 时表示函数不会抛出异常，
当 noexcept 是 false 时表示函数可能会抛出异常，可以定义在函数中，也可以单独使用`noexcept(函数名(实参))`检查函数声明的是true还是false。`void g() noexcept {};`带参用来检测某个行为是否会引发异常`template <class T> void swap(T &a, T &b) noexcept(noexcept (T(std::move(a))) && noexcept (a.operator=(std::move(b)))) `
```C++
struct stTestAlign
{
    char a;
    alignas(4) char b;
    stTestAlign()
    {
        cout << "sizeof(stTestAlign) =" << sizeof(stTestAlign) << endl;   //8
        cout << "alignof(stTestAlign) =" << alignof(stTestAlign) << endl; //4
    }
};
// 同时修改类的对齐依据，跟变量的(4)两者对齐依据取其大
struct alignas(2) stTestAlign
{
    char a;
    alignas(4) char b;
    stTestAlign()
    {
        cout << "sizeof(stTestAlign) =" << sizeof(stTestAlign) << endl;   //8
        cout << "alignof(stTestAlign) =" << alignof(stTestAlign) << endl; //4
    }
};

```
---
#### 类
* 常量成员函数` int GetYear() const { return y; }`。在函数中只能访问本类的其他常量成员函数，同时不能修改成员变量（除了标记为mutable的成员变量）
* 友元函数，在类外定义的函数在类内使用`friend`关键字再次声明后，该函数可以修改类的私有成员。也可以指定友元类，友元类的对象可以操作该类的私有成员。也可以仅令其他类的某个成员函数为友元函数:`friend type 类名::name(...);`
* 如果成员是const、引用，或者属于类类型，必须通过构造函数初始值列表为成员提供初值，不能放在打括号内初始化。`:i(放在这里){不能放在这里;}`
* 回避虚函数的机制，**强行调用某个版本的函数，`pojo.Class::func()`，这里强行调用了类Class中的函数版本**
* <font color="red">委托构造函数</font>，把构造函数初始化值的过程交给其它构造函数来完成。
```C++

class Person
{
public:
    Person() :Person(1, 'a') {}
    Person(int i) : Person(i, 'a') {}
    Person(char ch) : Person(1, ch) {} 
 
private:
    Person(int i, char ch) :type(i), name(ch) {/*其他初始化信息*/}
    int type{ 1 };
    char name{ 'a' };
};
```
* 字面值常量类：字面值类型的要求
    - 数据成员都必须是字面值类型
    - 类必须至少含有一个`constexpr`构造函数,`constexpr`构造函数必须初始化所有数据成员
    - 如果数据成员含有类内初始值，则该初始值必须是一条常量表达式，若成员为类类型，则初始值必须使用该类型的`constexpr`构造函数
    - 类必须使用析构函数的默认定义
* 类的静态成员函数使用：`类名::静态成员函数(...)`。类的静态成员定义在类外（除了静态**常量成员**可以定义在类内）：`type 类::成员变量名 = 初始化值`，即使静态成员在类内定义初始化后，也要在类的外部定义一下该成员。
> 静态成员和普通成员的区别，静态类成员类型可以就是他所属的类的类型，而普通成员必须是该类类型的指针或引用。
---

##### 拷贝、赋值、销毁

当定义一个类时，**通过定义5种特殊的成员函数控制这些操作，拷贝初始化（<font color="red">用等号定义变量</font>）通过拷贝构造函数或者移动构造函数实现的，`=delete`表示删除不使用该函数：**

* 拷贝构造函数：一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数为拷贝构造函数。**是用一个对象初始化另一个没有创建的对象**

  ~~~c++
  class Foo{
  public:
      Foo(const Foo&);
  }
  string Foo(...) // 直接初始化
  string s = Foo // 拷贝初始化
  ~~~

  

* 拷贝赋值运算符：**两个已经都存在的对象间进行赋值，一般会析构左侧对象，拷贝右侧对象。**

  ```c++
  Foo& operator=(const Foo&);
  ```

  >  <font color="red">拷贝和赋值运算符，都要注意传递将要赋值的对象!=(*this)</font>

* 移动构造函数

* 移动赋值运算符：

* 析构函数

> 拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么，拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。



---

##### Swap

一般类希望定义一个自己版本的swap，可以定义一个专属的swap友元函数。**将该函数声明为Inline用来优化加速，通常我们的交换只需要交换两个对象的指针。**

**类中保存的指针，在这种情形下的类，其赋值运算符可以使用`swap`处理自赋值：**

```c
Class& Class::operator=(Class c)
{
    swap(*this,c); // 这里交换时将一个值形参中的指针都交换给了this，其在函数结束时自动析构。
    return *this;
}
```

---

##### 移动构造函数和std::move

例如vector的`reallocate`函数，我们重新分配时，通常不希望创建额外的对象，而是希望**直接移动对象。**

`move`函数包含在头文件`utility`中。

`newValue = std::move(value)`通过move**进行调用移动构造函数**，使用`move`时，应说明命名域，`std::move(value)`。**不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept。同时在声明和定义处都要标记noexcept，若是不声明，为了避免移动过程中出现异常导致失败，可能会使用拷贝构造，为了确定其使用移动构造函数，必须显式声明noexcept**

```c
MyClass(MyClass&& other) noexcept: mData(other.mData), mSize(other.mSize)
    {
    要声明noexcept来表明移动构造函数不会抛出异常，否则标准库会认为我们的类对象时可能会抛出异常。
        other.mData = nullptr;
        other.mSize = 0;
    }
// 移动构造函数的示例，在函数块中应该将other的所有值都绑定到this。
```

**移动复制运算符：**在拷贝构造函数的基础上，使用`&&`

###### 右值引用：

符号：`&&`。如：`int &&i = 1;`

在移动构造函数中，形参的对象类型就是`&&`。我们通过`move`将一个左值对象转换成可以绑定到右值引用上的右值。

###### 移动迭代器

移动迭代器的解引用运算符生成一个右值引用。通过`make_move_iterator()`将一个普通迭代器转化为移动迭代器，如`make_move_iterator(begin())`，甚至更复杂的可以搭配：`uninitialized_copy(make_move_iterator(begin()),...)`**通过移动迭代器进行的复制**。像这个例子，我们可以搭配算法使用移动迭代器。

###### 总结：通常说来

一个成员函数可以定义两个版本，一个参数是左值引用类型的拷贝版本，一个参数是右值引用类型的移动版本。

##### 左值和右值引用成员函数

通常在参数列表后`()[&|&&]{...}`可以定义为`&`或者`&&`引用限定符，**该限定符必须同时出现在定义和声明中。对于`&`限定的函数，只能将其返回值用于左值，对于`&&`限定的函数，只能将其返回值赋予右值。成员函数支持同时定义`const`和引用限定：`()const [&|&&]{}`**

c++支持某些右值赋值，如：`string s1,s2;s1+s2 = "dwad";`

```c
//本对象为右值，因此可以原址排序
Foo Foo:sorted()&
{
	sort (data.begin(),data.end());
	return *this;
}
//本对象是cost或是一个左值，哪种情况我们都不能对其进行原址排序
Foo Foo::sorted()const&{
	Foo ret (*this);
	//拷贝一个副本
	sort(ret.data.begin(),ret.data.end());
	//排序副本
	return ret;
	//返回副本
}
```

<font color="red">对于引用限定符的成员函数重载的规则，如果定义两个或两个以上相同名字的成员函数，要么对所有该相同成员函数都加上引用限定符，或者都不加</font>

---



##### 重载运算符

本质上是函数，名字格式`returnType operator符号(参数)`。**某些运算符，包括赋值运算符（返回值是一个类型的引用）必须定义为成员函数。**

参数的数量与运算的对象数量一样多，如果是成员函数，则第一个运算对象隐式绑定到`this`上。

会改变对象状态的一般要定为成员函数：如，`%`定**为非成员函数**，`%=`定**为成员函数**

<font color="red">输入运算符必须处理可能输入失败的情况`if(in){成功}`，而输出不需要</font>

**几个容易出错的：**

* 下标运算符返回值通常是**引用**，一般定义一个常量版本，和一个非常量版本。

* 前置运算符，返回值是**引用**；后置运算符，返回值是**值**。**为了区分前置和后置，通常在后置运算符重载的参数中添加一个不被使用的`int`参数**

  * 前置++通常先检查当前指针是否为`end`，再++。而前置`--`则先`--`再check当前指针是否`<0`为无效指针。**而后置运算符不需要检查**

* 箭头运算符通常通过调用解引用运算符重载，**返回解引用运算符的地址**。

  ```c
  type* operator->()const {
      return & this->operator*();
  }
  ```

* 调用运算符可以让类对象拥有像函数一样的行为，可以代替`lambda`，**我们可以向泛型算法中传递一个实例作为param。**。

  ```c
  void operator()(const string &s)const{os<<s<<sep;}
  /////////////////////////////////////
  PrintString printer;
  printer(s);
  for_each(vs.begin(),vs.end(),PrintString()) // 
  ```

* 类型转换运算符：`operator type()const{};`**负责将一个类转换成其他类型，**该运算符不需要显式的返回类型以及形参。**若类型转换定义了`explicit`则需要`static_cast`显式转换，通常我们需要定义向`bool`的转换

##### 继承

冒号后，紧跟以逗号分隔的基类列表，每个基类前面可以有访问说明符。

**派生类可以调用基类的初始化列表：`():baseClass(baseV1,baseV2),v1(...)...`**

* 如果想将某个类作为基类，**作为基类的类不能仅仅是声明，必须已经定义。**

* `final`--`class c final{}`表示该类不能被继承

* 基类必须定义虚构函数为**虚析构函数**。

* 当基类中显式的定义了拷贝、移动函数，则派生类会自动获得合成的相应函数。

* **在派生类中想要拷贝或者构造基类的部分，必须使用初始化列表显式的调用基类的相应构造函数，移动的直接通过`move`**

  ```c
  // Base
  D &D::operator=(const D&rhs) {
      Base::operator=(rhs); // 为基类部分赋值
      ...
  }
  ```

  

**纯虚函数：`=0`**

<font color="red">只有派生类共有的继承基类时，用户代码才能使用派生类向基类的转换</font>

---

###### 派生类修改成员访问权限

派生类可以修改自己能访问到的基类成员的权限，**包括函数以及变量**。

```c
方法：如基类中有void add();
派生类要修改为Private权限：
private:
	using Base::add;
// 修改的权限类型为该using前可找到的第一个访问说明符决定
```

###### 继承的例子分析

![image-20230419215353012](https://github.com/xxn-1/image/blob/main/img/202304192153141.png)

![image-20230419215439721](https://github.com/xxn-1/image/blob/main/img/202304192154795.png)

![image-20230419215953696](https://github.com/xxn-1/image/blob/main/img/202304192159801.png)

在整个继承层次中，**我们不会暴露这些类，而是重新定义一个接口类，其中定义`Query_base`的接口类，由其负责隐藏整个体系。`&`生成`AndQuery`对象，其他运算符类似**

如：`Query("fiery")|Query("bird")&Query("hello")`

##### 动态绑定

基类的引用和指针，派生类都可以赋值。

绑定到基类引用的派生类调用自己的函数；绑定到基类指针的派生类调用基类的函数

```c
#include <iostream>
using namespace std;
class Base
{
public:
    virtual Base *clone() &
    {
        cout << "copy";
        return new Base(*this);
    }
    virtual Base *clone() &&
    {
        cout <<"move";
        return new Base(std::move(*this));
    }
    virtual void show()
    {
        cout << "nihao";
    }
};
------
#include "Base.h"
using namespace std;
class BaseOver : public Base
{
public:
    Base *clone() &
    {
        cout << "copy";
        return new BaseOver(*this);
    }
    Base *clone() &&
    {
        cout << "move";
        return new BaseOver(std::move(*this));
    }
    void show() override
    {
        cout << "nnnnn";
    }
};
-----
int main() {
    BaseOver t;
    Base* base1 = t.clone();
    
    base1->show();
}
```



---



##### 标准库定义的函数类型

标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的**模板类**。

**使用这些模板类可以使我们的程序更具有可移植性和类型无关的特性，结合我们定义的模板来编写函数**

**算术：**

* `plus`
* `minus`
* `multiplies`
* `divides`
* `modulus`
* `negate`

**关系：**

* `equal_to`
* `not_equal_to`
* `greater`
* `greater_equal`
* `less`
* `less_equal`

**逻辑：**

* `logical_and`
* `logical_or`
* `logical_not`
* 

#### 迭代器
迭代器要针对具体的容器类型<br/>

* `vector<int>::iterator it;string::iterator it;`支持读写的迭代器
* `vector<int>::const_iterator it;`仅支持读的常量指针
```c++
// begin() or end()
获取iterator类型
// cbegin() or cend()
获取const_iterator类型
// rbegin() or rend()
获取reverse_iterator类型 - 反向迭代器
// crbegin() or crend()
```
##### 类型
1. 插入迭代器，以下都是函数：
    * `back_inserter`借助push_back
    * `front_inserter`借助push_front
    * `inserter`借助insert，需要传入第二个参数，是一个迭代器
2. 流迭代器：绑定到输出或输入流，遍历IO流，使用时，需要创建两个迭代器，一个用于指定读入的流对象，另一个作为尾后迭代器
    * `istream_iterator<type>it(流对象)`
    * `istream_iterator<type>eof`作为尾后迭代器
    ```c++
    // 可以直接将流放到容器中
    istream_iterator< int > initer(cin),eof;
    vector< int > nums(initer,eof);
    // 或单独读出流中一个元素
    cout << *initer++;
    // 运用到泛型算法中
    accumulate(initer,eof,0);
    ```
    * `ostream_iterator<type> out_iter(cout," ")`其中接收一个输出流，第二个参数会在每次输出后默认输出一个" "。
     ```c++
    // 可以直接将流输出
    ostream_iterator< int > out_iter(cout);
    vector< int > nums;
    copy(nums.begin(),nums.end(),out_iter);
    // 或单独读出流中一个元素
    *out_iter = nums[0];
     
     ```
3. 反向迭代器
4. 移动迭代器：不拷贝元素，而是移动他们。
5. 



---
#### 异常
异常定义的几个头文件`exception`、`stdexcept`、`new`（包含bad_alloc异常）、`typeinfo`（包含bad_cast异常）
```c++
// stdexcept定义的几个异常
exception 最常见的问题
runtime_error 只有在运行时才能检测到的问题
range_error 运行时错误：超出有意义的范围
overflow_error 计算上溢出
underflow_error 下溢出
logic_error 程序逻辑错误
domain_error  参数对应的结果值不存在
invalid_argument 无效参数
length_error 超出该类型最大长度的对象
out_of_range 使用一个超出有效范围的值
```

* `throw 异常类型(信息);`
* `try`语句
```c++
try{

}catch(异常类型 e){

}catch(异常类型 e){

}
```
---
#### 类型转换
* `static_cast`常用于明确定义的强制类型转换
* `dynamic_cast`将基类指针转化到派生类指针。
* `const_cast`改变底层const的转换
* `reinterpret_cast`
---
#### IO库
包含三个重要的头文件：  
1. `iostream`:用于读写流，包含  
    `istream/wistream`:读取|`ostream/wostream`:写入|`iostream/wiostream`:读写  
2. `fstream`:用于读写命名文件:  
    `ifstream/wifstream`:读取|`ofstream/wofstream`:写入|`fstream/wfstream`:读写  
3. `sstream`:用于读写内存对象string对象  
    `istringstream/wistringstream`:读取|`ostringstream/wostringstream`写入|`stringstream/wstringstream`读写<br/>
    流的状态有4种：`badbit(s.bad(),指出流已崩溃)/failbit(s.fail(),表示IO操作失败了)/eofbit(s.eof(),表示流到文件结束)/goodbit`。可使用位运算设置多种状态一次性。  
    其它的一些函数：`s.clear()/s.clear(status)清除指定的状态`  、`s.rdstate()`返回当前的状态。`s.setstate(status)`<br>
    刷新输出缓冲区的方法：<br>
1. `endl`输出换行并刷新  
2. `ends`输出一个空白字符，然后刷新缓冲区  
3. `flush`不附加字符的刷新  
4. `cout << unitbuf/cout << nounitbuf`设置任何输出后都立即刷新缓冲区  
##### 输入输出流之间的关联
> 当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。

通过`s.tie()`返回与当前输入流相关联的输出流。通过`s.tie(输出流的地址)`将输出流关联到此输出流，输出流地址为`nullptr`时表示输入流不再与其他流关联。
##### 文件打开的几种模式
这些模式放在命名域`ios_base::`下：  
1. in  
2. out  
3. binary  
4. ate打开的时候定位到文件末尾  
5. app每次写操作前都定位到文件末尾  
6. trunc丢弃打开前文件的内容  
几个限制：
```c++
1. 只能对ofstream只能设置out，ifstream只能设置in
2. 只有设定为out后才能设置trunc
3. 没有设定trunc才能设定app
4. 默认情况以out打开文件会丢弃文件内容，需要指定app模式。
```
##### sstream
一些函数：  
1. `strm.str()`返回sstream保存的string，`strm.str(s)`将string s拷贝进sstream中。  

---
#### 容器
##### 顺序容器
`vector、deque、list、forword_list、array、string`  
顺序容器的几种类型别名：
1. iterator  
2. const_iterator  
3. size_type  
4. difference_type  
5. value_type  
6. reference  
7. const_reference  
> 容器初始化拷贝时，不通过迭代器的初始化都要求容器的类型相同。  
容器array的使用，除了定义类型，还要定义大小：`array<int,32>a;`

顺序容器适配器：`queue、priority_queue、stack`
```C++
// 适配器默认情况下queue和stack是基于deque实现的，而priority_queue是基于vector实现的
如：stack<int>s;
// 支持重载容器类型，通过设置第二个参数
stack<int,vector<int>>s;
// stack支持除array和forword_list之外的所有容器
// queue支持构造在list和deque上
// priority_queue支持构造在vector和deque上
```
##### 关联容器
* `map`:包含`.first、.second`两个成员，关键字不能修改，值允许。
* `set`值不能修改
* `multimap`
* `multiset`
* `unordered_map`
* `unordered_set`
* `unordered_multimap`
* `unordered_multiset`
>注意：这些有序容器的元素类型必须支持比较操作'<'，如list列表并不支持所以不能作为元素。
这些容器可以重载比较运算符，我们需要传递一个重载的函数指针，以及具体的函数，如：
```C++
bool compareIs(const int &a, const int &b)
{
    return a > b;
}
vector< int > vs = {421, 12, 4321, 23, 5241, 211, 53532, 121};
set< int, decltype(compareIs) * > nums(vs.begin(), vs.end(), compareIs);
```
**这些关联容器的`insert`操作会返回一个`pair`类型，`first`是一个`map`迭代器位置，`second`是一个`bool`表示是否插入成功**
* `lower_bound`返回指向第一个具有给定关键字的元素
* `upper_bound`返回最后一个匹配给定的关键字的元素之后的位置
* `equal_range`返回一个pair，包含相等元素的首和尾迭代器
###### 无序容器

无需容器的桶策略

![][642e59e5a682492fcca021bee.png]  
不同关键字哈希后可能分配到相同的桶后，再顺序比较

**无序容器若想定义其类型为自定义类型，需要重载`==`运算符和哈希值计算函数**：

```C++
size_t hasher(const Student& stu) {
    return hash<string>()(stu.id); // 库函数
}
bool eq(const Student& stu1,const Student& stu2) {
    return stu1.id == stu2.id;
}
unordered_multiset<Student,decltype(hasher)*,decltype(eq)*>s(42,hasher,eq);
```



##### pair类型
* `pair<type1,type2>p;`
* 构造：`make_pair(v1,v2)`返回一个pair。
---
#### 泛型算法
大多数定义在头文件`<algorithm>`中，`numeric`定义了一些数值算法。[algorithm算法库][algorithm]。这些算法是支持不同容器中不同类型的比较的，前提是这些类型的比较是允许的。  
    泛型算法的特点:算法总是通过<font color="red">迭代器</font>操作容器，因此不能直接向/从容器添加、删除元素，无法改变容器大小。**泛型算法对于容器的要求并不是有足够的空间，而是有足够的元素。即.size()的大小要足够，因此对一个空容器调用reserve(n)也是不可以的；只能通过插入迭代器函数来完成改变元素个数的操作**
> sort算法是利用元素类型的“<”来实现排序的
##### 插入迭代器(back_inserter)函数
接受一个指向容器的引用，返回一个插入迭代器。向返回的插入迭代器赋值时，会调用`push_back`将该值插入到容器中。例子：
```C++
vector<int>vec;
fill_n(back_inserter(vec),10,0);//借助插入迭代器向和泛型算法fill_n向容器中插入10个0。
```
---
##### 谓词
某些泛型算法还有重载后的版本，接受第三个参数，此参数是一个**谓词**。本质是一个可调用的表达式，返回结果是一个能用作条件的值。谓词的类型共有两种：一元谓词、二元谓词。
>注意：谓词在泛型算法中只用写出谓词函数的名字，不用写实参。
---
##### lambda表达式
通常形式为:`[捕获列表](参数列表)mutable throw(类型)->返回类型{函数体};`  
捕获列表讲解：lambda通常只能访问使用外部的全局变量，而不能使用函数里的局部变量，因此需要捕获列表。[x,y,z]如上，三个局部变量补获后已经可以在lambda中使用了。捕获的方式分为：<br>
* 按值捕获:若按值捕获时想要修改变量的值，需要添加上`mutable`关键字。  
* 引用捕获`[&x,&y]`  
* 隐式捕获，包含：  
&nbsp;&nbsp;1. `[=]`:函数局部作用域里的所有变量都按值捕获  
&nbsp;&nbsp;2. `[&]`:函数局部作用域里的所有变量都按引用捕获  
&nbsp;&nbsp;3. `[=, reference_list:]`:reference list里的变量按引用捕获，其余的变量按值捕获，比如 [=, &a, &b] 表示 a 和 b 按引用，其余按值捕获   
&nbsp;&nbsp;4. `[&, identifier_list]`identifier list里的变量按值捕获，其余的变量按引用捕获，比如 [&, a, b] 表示 a 和 b 按值，其余按引用捕获  

使用：
```C++
auto f = []()->{return 3;}
cout << f() << endl;
```
---
##### bind函数
定义在`<functional>`头文件中  
可以将参数绑定在某个函数上，返回新的函数句柄。假如我们已经拥有函数test，`bind`函数有些特殊参数:`_1`、`_2`等等，若是使用这些参数，则会将调用函数f传来的形参传递给test调用，而bind还支持自己定义默认的参数绑定到test上。。`auto f = bind(test,_1,...)`
> 注意：这些占位符都放在`placeholders`命名空间中

但是若希望在bind函数中传递某些无法拷贝的值，就需要传递引用，因此可以借助`ref`或`cref`函数。如`ostream s;bind(test,ref(s))`

#### 智能指针

都定义在`<memory>`头文件中，以下智能指针都是模板，需要提供**类型**。

* `shared_ptr<type>`计数器为0时自动释放，**注意，不要使用一个智能指针get得到的指针去初始化另一个智能指针，这可能导致该指针分配的内存随时可能被delete。**

  ```c++
  shared_ptr<string>p
  if(p && p->empty) // 如果p指针不为空，且指向一个空string。
  shared_ptr<T> ptr(new T()); // ptr引用计数为0时，对象自动释放。
  ```

  * `p.get()`获得智能指针中保存的指针。
  * `make_shared<type>(参数)`使用指针初始化返回一个shared_ptr，这里参数并不限，比如说可以是`make_shared<int>(32)`指向一个int为32的指针。
  * `p.unique()`判断其引用是否为1
  * `p.use_count()`返回其共享对象的智能指针数量

  **自定义删除器：对于自己的类型，需要重载shared_ptr的删除器，方法为定义一个函数，函数参数为该类型指针，在函数中释放相关内存，初始化shared_ptr(变量，删除器)。注意跟unique_ptr有点不同，例子：`share_ptr<type>p(new type(),mydelete)`**

* `unique_ptr<type>`，该类型必须使用直接初始化的方式，并且要绑定到一个**new**的指针上，可以使用`p.reset(p1.release())`转移其唯一的所有权，该类型通常是不能拷贝或赋值的，但是也有特殊情况，即是在函数中作为局部变量返回时，返回该局部对象的拷贝

  ​	![image-20230409135506257](https://cdn.jsdelivr.net/gh/xxn-1/image/img/202304091355398.png	)

  自定义删除器：`unique_ptr<type,decltype(mydelete)*>p(new type(),mydelete)`

* `weak_ptr<type>`是一个不控制所指向对象生存期的智能指针，指向由一个`shared_ptr`管理的对象，将其绑定到一个`shared_ptr`不会改变该`shared_ptr`的引用计数器。**初始化需要**直接被一个`shared_ptr`对象赋值。**使用的途径：通常可以作为为一个容器类定义指针时，用来检查的指针。**

  * `lock()`
  * `reset()`
  * `expired()`
  * `lock()`如果指向的shared_ptr引用计数为0，返回空的shared_ptr对象，否则返回一个shared_ptr。

  ```c++
  shared_ptr<int> p(new int(3));
  weak_ptr<int>pp = p;
  if(p == pp.lock()) { 
      // 安全
  }
  ```

  

##### 动态内存

对于`new`的方式分配内存时，希望阻止其抛出异常，可以使用` ... = new (nothrow) type;`

##### 动态数组

标准库提供了一个特殊版本的`unique_ptr`管理这样的动态数组。`unique_ptr<int[]>up(new int[10])`，`up[i]`下标访问，`up.reset()`自动用`delete[]`释放。

`shared_ptr`与`unique_ptr`有所不同，要使用其管理动态数组，需要提供自己的删除器，并且不支持访问，必须使用get()函数获取原始指针。`shared_ptr<int>sp(new int[10],[](int*p){delete []p;};`**注意，这里的类型不是数组类型。**

###### allocator

传统的new会在分配内存时同时为分配的对象进行初始化，**但往往我们可能会一次性分配大量对象内存，同时可能只会使用其中一小部分，这个时候就需要将分配内存和初始化分开**

`allocator`类支持该操作。是一个**模板类**。

```c++
allocator<type>alloc;
auto p = alloc.allocate(n); // 分配n个未初始化的string
a.deallocate(p,n); // 释放p开始的n个类型为type的对象内存，在destory之后这段allocate的空间可以重新构造，若是不想使用这段空间，可以调用该函数，n等于allocate时的n，释放空间，今后将不能再构造初始化。
a.construct(p,参数列表); // 参数列表传递给p当前指向的对象构造函数初始化。
a.destory(p);  // 对p指向的对象执行析构函数，注意只需要对指针调用了construct的指针p执行该destory操作

释放时，推荐从尾向首释放
```

![allocator的伴随算法](https://github.com/xxn-1/image/blob/main/img/202304091552562.png)

#### 标准库

##### function

定义在`functional`中，使得我们可以方便的将**类形式函数调用，lambda形式调用，函数指针形式的调用**形式**使用统一的`function`模板保存，从而建立一个函数表，通过`map`**。如：

```c
function<int(int,int)>f1 = add; (add是一个int (int,int)的函数)
function<int(int,int)>f2 = divide();
function<int(int,int)>f3 = [](int i,int j);
f1(1,2); 即可调用
map<string,function<int(int,int)>>maps; // 函数表
```



#### __attribute__属性

#### 模板

##### 函数模板

**函数声明需要声明模板参数，但允许不定义。**

* 模板类型参数：`template <typename T,typename T1...> 类型 func(...){}`

* 非模板类型参数：`template<typename T,int SIZE>test{cout << SIZE;}||test<int,5>(形参)`在尖括号内可以添加非类型参数，**其值必须为常量值**。**通常可以用来获得容器中的元素个数，编译器会在编译时期用数组的长度初始化N**

  ```c
  template<typename T,size_t N>
      void print(const T (&a)[N])
  {
      
  }   
  ...
  int a[2] = {1,2};
  print(a);
  //////////////////////////////////////
  #include "iostream"
  using namespace std;
  template <typename T,size_t N>
  void getSum(const T (&a)[N])
  {
      cout << N << endl;
      T sum;
      for(auto x:a){
          sum += x;
      }
      cout << sum << endl;
  }
  int main() {
      int a[2] = {2,3};
      getSum(a);
      string b[2] = {"dfwsefd","fre222"};
      getSum(b);
  }
  ```

  

* `inline`和`constexpr`的函数模板，这两个关键字必须放在模板参数列表尖括号后，返回类型之前。

##### 类模板



```c
template <typename T,...> class 类名
{
    
}
```

**特例化：**

```c
template <> class 类名<int> {
};
// 特例化int
```

定义的模板成员函数：

```c
template <typename T> Blob<T> Blob<T>::func(...)
    // 凡是有类类型出现的地方，都要给出<T>
```

**通常情况下，static成员变量需要定义为模板，**

```c
template <typename T,...> class Foo
{
 	static std::size_t count;   
}
template <typename T> size_t Foo<T>::count = 0;
```



----



如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例，如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。

* 一对一：`friend type func<T>()||friend class B<T>;`
* pal的所有实例都是当前类友元：`template<typename X>friend class pal;`
* 模板参数成为友元：`friend T;`

##### 模板类型别名

`template <typename T,...> using alias = map<T,int>`

`alias<int> == map<int,int>`



#### 位域和bit

```c
union {
        struct
        {
            unsigned char a1:2;
            unsigned char a2:3;
            unsigned char a3:3;
        }x;
        unsigned char b;
}d;
d.b=100
    
```



#### C++11新特性
#### C++14新特性

#### C++17新特性

[algorithm]: https://learn.microsoft.com/zh-cn/cpp/standard-library/algorithm?source=recommendations&view=msvc-170
[642e59e5a682492fcca021be.png]: https://pic.imgdb.cn/item/642e59e5a682492fcca021be.png
[642e59e5a682492fcca021bee.png]:https://pic.imgdb.cn/item/642e59e5a682492fcca021be.png
