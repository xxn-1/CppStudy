**记录一些遗漏的C++知识点**

[TOC]

---
#### 基础遗漏
1. `e`指数表示：`1.3e3`表示1300
2. 末尾可以用`\`换行
3. 字面值常量的前缀和后缀添加，改变默认类型，在不同类型上应用会有不同效果。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符、字符串(前缀):
    * `u`char16_t
    * `U`char32_t
    * `L`wchar_t
    * `u8`char(UTF-8)  
    整形:
    * `u/U`unsigned
    * `l/L`long
    * `ul/UL`unsigned long
    * `ll/LL`long long  
    浮点数:
    * `f/F`float
    * `l/L`long double
4. 变量声明和定义的区别。一个变量能且仅能够被定义一次，但是可以被多次声明(extern)，声明时不需要初始化，若是声明时初始化则不是声明而是定义，如`extern int i = 3`已经变化为定义。
5. `::变量名`显式的访问全局变量中的变量，若是有局部变量名与全局变量名相同时，可以如此访问。`::i/i`（全局作用域没有名字）
6. 引用的类型必须与所引用的对象的类型一致。除了：
    * `const int &r = 10;`正确，直接用常量值绑定
    * `int i = 1;int &r1 = i;const int &r2 = i;`此时可以通过r1或直接修改i的值，但是不能通过r2修改值。
7. 指针和const
    * `const int *p = &i;`此时p指向的地址可以修改，但是不能改变其所指地址对象的值，并不要求所指对象是常量值，仅仅是表示不能通过该指针修改其值。
    * `int *const p = &i;`表示指针本身是常量，其所指的地址不能改变。
    * `const int *const p =&i;`**一般把前const称作底层const,后const称作顶层const，拷贝赋值时必须有相同的底层const。当然普通类型可以转化为const类型，反之不行。**
8. 常量表达式关键字`constexpr`，常量表达式由**数据类型**和**初始值**共同决定。  
    * `constexpr int t = 20;`常量表达式
    * `constexpr int sz = size()`**只有size()函数是一个constexpr函数时才是正确的声明语句，新标准允许定义一种特殊的constexpr函数(返回值必须是字面值常量，传递进去的实参必须是字面值常量，函数体中必须有且仅有一条return语句)<font color='red'> |算术类型、引用、某个固定地址的指针都属于字面值常量| </font>使得编译时就获得结果**
    > 注意，`constexpr`修饰指针时与const不同，`constexpr int *p = nullptr`表示p该指针指向不能改变。
9. 基于范围的for语句  
```c++
// string a - 处理每个字符
for(auto c:a) {
    cout << c;
}
// 若要改变字符，需要使用引用
for(auto &c:a) {
    c = c + '1';
}
// 若要处理多维数，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型
for(auto &row:a) {
    for(auto &x:row){
        ...
    }
}
```
10. 数组的指针
    * `int *ptr[10];`含有10个整型指针的数组
    * `int (*ptr)[10]`指针指向一个含有10个整数的数组
    * `int &ptr[10];`不存在引用的数组
    * `int (&ptr)[10];`引用一个含有10个整数的数组  
    > 头文件`<iterator>`定义了函数`begin()/end()`方便我们获得数组的头指针和尾元素下一个位置的指针。
11. char数组的比较：不能直接使用运算符比较，此时比较的是指针而非值本身。要使用`strcmp`
---
#### 类型处理
##### 别名
&nbsp;&nbsp;推荐使用`using`代替`typedef`，`using`比起`typedef`来易读，并且支持模板别名。</br>

* `using func = void(*)(int);`
* `template<typename T> using map_ss = unordered_map<std::string, T>;`<br/>
`map_ss<int> unmap;// ==> unordered_map<std::string, int> unmap;`

##### 类型推导
* `auto`关键字，推导时会去掉顶层const，需要手动加`const auto i = 1;`
* `decltype(变量/值...)`，获取某个值的类型，`decltype(sum()) x = sum()`;`decltype`中的值如果加了括号，如`decltype((i))`(->一定为引用的类型)和`decltype(i)`不同。
* 

---
#### 特性
* `[[noreturn]]` 指定函数永不返回
* `[[carries_dependency]]`指定函数传播线程同步的数据依赖项顺序。 可将该属性应用于一个或多个参数，以指定传入的参数要将依赖项带入函数主体中。 可将该属性应用于函数本身，以指定返回值要将依赖项带出函数。 编译器可以使用此信息来生成更有效的代码。
* `[[deprecated]]`特性 [[deprecated]] 可以应用于类、typedef-name、变量、非静态数据成员、函数、命名空间、枚举、枚举器或模板专用化的声明。 当客户端代码尝试调用该函数时，编译器可以使用此属性来生成信息性消息。 当Microsoft C++ 编译器检测到项的使用[[deprecated]]时，会引发编译器警告 C4996。
* `[[fallthrough]]`指定函数的返回值不应被丢弃。
* `[[nodiscard]]`
* `[[maybe_unused]]`
* `[[likely]]`
* ``[[unlikely]]``
---
#### 命名空间
* `using namespace 命名空间名`使用该命名空间所有名字
* `using 命名空间名::具体名字`，如:`using std::cin`
---
#### 运算符
* `typeid`定义在<typeinfo>头文件中，允许在运行时获得变量的类型名。例子：`int a;cout << typeid(a).name();`可以在模板中使用，确定类型。`typeid(T).name()`
* `alignof(类型名)`返回类型的字节数。`class Car{};cout << alignof(Car);`
* `alignas(类型名)`修改单独变量或者类的对齐大小，在定义时添加使用
* `sizeof...(name)`参数包的大小
* `throw expr`抛出异常
* `noexcept(expr)`不带参数等价于true，当 noexcept 是 true 时表示函数不会抛出异常，
当 noexcept 是 false 时表示函数可能会抛出异常，可以定义在函数中，也可以单独使用`noexcept(函数名(实参))`检查函数声明的是true还是false。`void g() noexcept {};`带参用来检测某个行为是否会引发异常`template <class T> void swap(T &a, T &b) noexcept(noexcept (T(std::move(a))) && noexcept (a.operator=(std::move(b)))) `
```C++
struct stTestAlign
{
    char a;
    alignas(4) char b;
    stTestAlign()
    {
        cout << "sizeof(stTestAlign) =" << sizeof(stTestAlign) << endl;   //8
        cout << "alignof(stTestAlign) =" << alignof(stTestAlign) << endl; //4
    }
};
// 同时修改类的对齐依据，跟变量的(4)两者对齐依据取其大
struct alignas(2) stTestAlign
{
    char a;
    alignas(4) char b;
    stTestAlign()
    {
        cout << "sizeof(stTestAlign) =" << sizeof(stTestAlign) << endl;   //8
        cout << "alignof(stTestAlign) =" << alignof(stTestAlign) << endl; //4
    }
};

```
---
#### 迭代器
迭代器要针对具体的容器类型<br/>

* `vector<int>::iterator it;string::iterator it;`支持读写的迭代器
* `vector<int>::const_iterator it;`仅支持读的常量指针
```c++
// begin() or end()
获取iterator类型
// cbegin() or cend()
获取const_iterator类型
```
---
#### 异常
异常定义的几个头文件`exception`、`stdexcept`、`new`（包含bad_alloc异常）、`typeinfo`（包含bad_cast异常）
```c++
// stdexcept定义的几个异常
exception 最常见的问题
runtime_error 只有在运行时才能检测到的问题
range_error 运行时错误：超出有意义的范围
overflow_error 计算上溢出
underflow_error 下溢出
logic_error 程序逻辑错误
domain_error  参数对应的结果值不存在
invalid_argument 无效参数
length_error 超出该类型最大长度的对象
out_of_range 使用一个超出有效范围的值
```  

* `throw 异常类型(信息);`
* `try`语句
```c++
try{

}catch(异常类型 e){

}catch(异常类型 e){

}
```
---
#### 类型转换
* `static_cast`常用于明确定义的强制类型转换
* `dynamic_cast`将基类指针转化到派生类指针。
* `const_cast`改变底层const的转换
* `reinterpret_cast`
---
#### __attribute__属性

#### C++14新特性

#### C++17新特性

